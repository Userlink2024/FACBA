<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extractor Inteligente de Comprobantes (Libro XLSX)</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería SheetJS (xlsx) para generar archivos de Excel de múltiples hojas -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.5/dist/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        /* Estilos generales para un aspecto limpio */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }
        /* Estilo para el spinner de carga */
        .spinner {
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center p-4">

    <div class="w-full max-w-2xl bg-white shadow-2xl rounded-xl p-8 space-y-6">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center border-b pb-4">
            Sistema de Extracción de Comprobantes (Múltiple)
        </h1>

        <!-- SECCIÓN 1: Carga de Imagen -->
        <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-200">
            <label for="imageUpload" class="block text-lg font-semibold text-blue-800 mb-2">
                1. Adjuntar Comprobantes (Múltiples Archivos)
            </label>
            <input type="file" id="imageUpload" accept="image/*" multiple class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-100 file:text-blue-700
                hover:file:bg-blue-200"
            />
            <button id="processButton" class="w-full mt-4 py-2 px-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md disabled:opacity-50" disabled>
                Extraer Datos de <span id="fileCount">0</span> Archivos
            </button>
        </div>

        <!-- SECCIÓN 1.5: Selección de Campos -->
        <div class="bg-indigo-50 p-4 rounded-lg border-2 border-indigo-200">
            <label class="block text-lg font-semibold text-indigo-800 mb-2">
                1.5. Seleccionar Campos a Extraer
            </label>
            <p class="text-sm text-indigo-600 mb-3 font-medium">
                Nota: Los campos **Fecha** y **Nombre del Destinatario** son importantes para las reglas de consistencia y agrupación.
            </p>
            <!-- Selector de todos los campos -->
            <div class="flex items-center mb-4 pb-2 border-b border-indigo-300">
                <input type="checkbox" id="selectAllFields" class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                <label for="selectAllFields" class="ml-2 text-sm font-bold text-indigo-900 cursor-pointer">
                    Seleccionar/Deseleccionar Todos los Campos
                </label>
            </div>
            <!-- Fin Selector de todos los campos -->

            <div id="fieldSelection" class="flex flex-wrap gap-4">
                <!-- Los checkboxes se insertan aquí por JavaScript -->
            </div>
        </div>


        <!-- SECCIÓN DE CARGA Y ERRORES -->
        <div id="loadingArea" class="hidden text-center p-4 bg-yellow-100 rounded-lg">
            <div class="flex items-center justify-center space-x-2">
                <div class="spinner border-4 border-t-4 border-gray-200 h-6 w-6 rounded-full"></div>
                <span id="loadingMessage" class="text-yellow-800 font-medium">Analizando imagen con IA...</span></span>
            </div>
        </div>
        <div id="errorArea" class="hidden text-center p-4 bg-red-100 text-red-700 rounded-lg font-medium">
            Ocurrió un error. Por favor, revisa la consola para más detalles.
        </div>
        
        <!-- SECCIÓN 2: Resultados y Selección -->
        <div id="resultsArea" class="hidden space-y-4 bg-green-50 p-6 rounded-xl border-2 border-green-200">
            <h2 class="text-xl font-bold text-green-800 mb-4">2. Resultados Consolidados <span class="text-sm font-normal text-gray-600">(Selecciona qué filas exportar)</span></h2>
            
            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 mb-4 pb-2 border-b border-green-300">
                <!-- Selector de todas las filas -->
                <div class="flex items-center">
                    <input type="checkbox" id="selectAllResults" class="w-4 h-4 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 cursor-pointer result-select-master">
                    <label for="selectAllResults" class="ml-2 text-base font-bold text-green-800 cursor-pointer">
                        Seleccionar Todas
                    </label>
                </div>
                <!-- Botón/Selector para Excepciones de Fecha -->
                <button id="selectDateExceptionsButton" class="text-sm font-semibold py-1 px-3 rounded-full bg-orange-100 text-orange-800 hover:bg-orange-200 transition duration-150 shadow-md">
                    Seleccionar Solo Excepciones de Fecha
                </button>
            </div>
            
            <div id="dataList" class="space-y-4">
                <!-- Los resultados por archivo se insertarán aquí, separados por duplicados -->
            </div>

            <!-- SECCIÓN 3: Descarga -->
            <button id="downloadButton" class="w-full py-3 px-4 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-lg disabled:opacity-50 mt-6" disabled>
                Descargar Libro de Excel (XLSX) Agrupado por Destinatario
            </button>
        </div>
        
        <p id="infoMessage" class="text-sm text-gray-500 text-center"></p>
    </div>

    <script>
        // --- Variables Globales y Configuración de Gemini ---
        const imageUpload = document.getElementById('imageUpload');
        const processButton = document.getElementById('processButton');
        const downloadButton = document.getElementById('downloadButton');
        const loadingArea = document.getElementById('loadingArea');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorArea = document.getElementById('errorArea');
        const resultsArea = document.getElementById('resultsArea');
        const dataList = document.getElementById('dataList');
        const fileCountSpan = document.getElementById('fileCount');
        const infoMessage = document.getElementById('infoMessage');
        const fieldSelectionDiv = document.getElementById('fieldSelection'); 
        const selectAllFieldsCheckbox = document.getElementById('selectAllFields'); 
        const selectAllResultsCheckbox = document.getElementById('selectAllResults'); 
        const selectDateExceptionsButton = document.getElementById('selectDateExceptionsButton');
        
        // *****************************************************************************
        // *** IMPORTANTE: CLAVE API INYECTADA *****************************************
        // *****************************************************************************
        // ATENCIÓN: Se ha insertado la clave API proporcionada por el usuario para permitir el funcionamiento en dominios externos (GitHub Pages).
        const apiKey = "AIzaSyA9J-b9rH1CCMOKUmFxoI4n2B9fiY-RNv4"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        // allExtractedData ahora almacenará el resultado y las banderas de duplicado/excepción: 
        // {fileName, data, isDuplicate: boolean, isDateException: boolean, observation_date: string}
        let allExtractedData = []; 
        
        // Mapeo de meses en español (para la conversión de fecha)
        const MONTH_MAP = {
            'ene': 0, 'feb': 1, 'mar': 2, 'abr': 3, 'may': 4, 'jun': 5, 
            'jul': 6, 'ago': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dic': 11,
            'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5, 
            'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
        };


        // Metadata de los campos disponibles (SOLO para la extracción de la IA)
        const FIELD_METADATA = {
            value: { 
                label: 'Valor de la transferencia', 
                description: "El valor de la transferencia con el símbolo de moneda, por ejemplo $78.465." 
            },
            receipt_number: { 
                label: 'Nº Comprobante', 
                description: "El número de comprobante completo, por ejemplo 0000093600." 
            },
            date: { 
                label: 'Fecha', 
                description: "La fecha de la transferencia, por ejemplo 10 Oct 2025." 
            },
            time: { 
                label: 'Hora', 
                description: "La hora de la transferencia, por ejemplo 11:36 a. m.." 
            },
            recipient: {
                label: 'Nombre del Destinatario',
                description: "El nombre completo o razón social del destinatario de la transferencia."
            }
        };

        // --- Funciones de Utilidad ---

        /**
         * Intenta convertir una cadena de fecha extraída (ej: '10 Oct 2025' o '7-oct-25') 
         * a formato corto DD/MM/AAAA (ej: '10/10/2025').
         * @param {string} dateString La cadena de fecha extraída por la IA.
         * @returns {string} La fecha formateada (DD/MM/AAAA) o la cadena original, o 'FECHA_NO_ENCONTRADA' si es nula.
         */
        function formatDateShort(dateString) {
            if (!dateString) return "FECHA_NO_ENCONTRADA";
            
            // Intenta encontrar el patrón DD [MES] AA(AA)
            const parts = dateString.trim().split(/[\s\-/]+/);
            
            if (parts.length < 3) return dateString; // No tiene suficientes partes

            let day = parseInt(parts[0]);
            let monthStr = parts[1].toLowerCase().substring(0, 3);
            let year = parseInt(parts[2]);

            // Buscar el índice del mes (0-11)
            const monthIndex = MONTH_MAP[monthStr];

            if (isNaN(day) || monthIndex === undefined || isNaN(year)) {
                // Si no se puede parsear, devolvemos la cadena original
                return dateString;
            }

            // Normalizar el año de 2 dígitos a 4 dígitos (ej: 25 -> 2025)
            if (year < 100) {
                // Asumimos años del 2000 en adelante
                year = 2000 + year; 
            }

            // Convertir a formato DD/MM/AAAA
            const formattedDay = String(day).padStart(2, '0');
            const formattedMonth = String(monthIndex + 1).padStart(2, '0');
            
            return `${formattedDay}/${formattedMonth}/${year}`;
        }
        
        // Inicializa los checkboxes de selección de campos (Marcar Fecha, Comprobante y Destinatario por defecto)
        function initFieldSelection() {
            fieldSelectionDiv.innerHTML = '';
            // Marcar 'Fecha', 'Nº Comprobante' y 'Nombre del Destinatario' por defecto
            const defaultCheckedFields = ['date', 'receipt_number', 'recipient']; 
            
            Object.keys(FIELD_METADATA).forEach(key => {
                const field = FIELD_METADATA[key];
                
                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-center';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `field-${key}`;
                checkbox.value = key;
                checkbox.checked = defaultCheckedFields.includes(key); 
                checkbox.className = 'w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer field-select-item';

                const label = document.createElement('label');
                label.htmlFor = `field-${key}`;
                label.className = 'ml-2 text-sm font-medium text-gray-700 cursor-pointer';
                label.textContent = field.label;

                wrapper.appendChild(checkbox);
                wrapper.appendChild(label);
                fieldSelectionDiv.appendChild(wrapper);
            });
            // Asegurar que el checkbox principal de campos esté desmarcado al inicio si no todos están marcados
            const allItems = Object.keys(FIELD_METADATA).length;
            selectAllFieldsCheckbox.checked = allItems === defaultCheckedFields.length; 
        }
        initFieldSelection(); 

        // Obtiene los campos seleccionados (las claves del JSON)
        function getSelectedFields() {
            const selected = [];
            fieldSelectionDiv.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
                selected.push(checkbox.value);
            });
            return selected;
        }

        /**
         * Convierte el archivo a una cadena Base64 PURA (sin prefijo) para la API.
         * @param {File} file El objeto File.
         * @returns {Promise<string>} La cadena Base64.
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                // ESTA ES LA CLAVE: extraer solo la parte después de la coma.
                reader.onload = () => {
                    try {
                        const base64Data = reader.result.split(',')[1];
                        if (base64Data) {
                            resolve(base64Data);
                        } else {
                            reject(new Error("Error al obtener datos Base64. Formato de archivo inválido."));
                        }
                    } catch (e) {
                         reject(new Error("Error de codificación Base64: " + e.message));
                    }
                };
                reader.onerror = error => reject(error);
            });
        }
        
        // Muestra u oculta elementos de la interfaz
        function setUIState(isLoading, isError, resultsVisible) {
            loadingArea.classList.toggle('hidden', !isLoading);
            processButton.disabled = isLoading || imageUpload.files.length === 0;
            errorArea.classList.toggle('hidden', !isError);
            resultsArea.classList.toggle('hidden', !resultsVisible);
            downloadButton.disabled = true; 
        }

        /**
         * Llama a la API de Gemini con lógica de reintento (backoff)
         */
        async function fetchWithRetry(url, payload, maxRetries = 5) {
            let delay = 1000;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && i < maxRetries - 1) { 
                        console.warn(`Tasa límite alcanzada. Reintentando en ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }

                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => ({}));
                        const errorMessage = errorBody.error?.message || response.statusText;
                        
                        // Si es un error de Base64, dar un mensaje más claro
                        if (errorMessage.includes("Unsupported content") || errorMessage.includes("Invalid content")) {
                            throw new Error(`Error de contenido de imagen. Asegúrese de que el archivo es una imagen válida (JPEG, PNG). Detalle: ${errorMessage}`);
                        }
                        
                        throw new Error(`Error en la API: ${response.status} - ${errorMessage}`);
                    }
                    
                    return response.json();

                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    console.error("Error temporal. Reintentando...", error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
            throw new Error("Fallo en la llamada a la API después de múltiples reintentos.");
        }

        /**
         * Procesa una sola imagen usando la API
         */
        async function processSingleImage(file) {
            const selectedFields = getSelectedFields();
            if (selectedFields.length === 0) {
                throw new Error("Debe seleccionar al menos un campo para extraer.");
            }

            // USAR fileToBase64 para obtener la Base64 PURA.
            const base64Data = await fileToBase64(file); 

            // 1. Construcción dinámica de Prompts y Schema
            let promptList = [];
            let schemaProperties = {};
            
            selectedFields.forEach(key => {
                const metadata = FIELD_METADATA[key];
                // Pedimos a la IA que sea lo más consistente posible con el dato, 
                // incluso pidiendo la fecha en un formato estandar
                let description = metadata.description;
                if (key === 'date') {
                    // CRÍTICO: Pedir la fecha en un formato específico para que el parseo sea más robusto
                    description += " Devuélvela en el formato DD MES AAAA (ej: 07 Oct 2025)";
                }

                promptList.push(`'${metadata.label}'`); 
                schemaProperties[key] = {
                    type: "STRING",
                    description: description
                };
            });
            
            const fieldsToExtract = promptList.join(', '); 
            
            const systemPrompt = `Eres un asistente de extracción de datos especializado en recibos de transferencia. Tu única tarea es extraer únicamente los campos solicitados y devolverlos estrictamente en formato JSON, sin texto adicional o explicaciones. Los campos a buscar son: ${fieldsToExtract}.`;
            
            const userPrompt = `Por favor, extrae los siguientes datos de la imagen: ${fieldsToExtract}.`;

            // 2. Construcción del payload
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: userPrompt },
                            {
                                inlineData: {
                                    // USAR file.type AQUÍ (Tipo MIME del archivo original)
                                    mimeType: file.type, 
                                    data: base64Data
                                }
                            }
                        ]
                    },
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: schemaProperties,
                        propertyOrdering: selectedFields 
                    }
                },
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            const result = await fetchWithRetry(apiUrl, payload);
            
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Respuesta de la IA vacía o mal formada.");
            
            return JSON.parse(jsonText);
        }

        /**
         * Implementa la lógica de CONSISTENCIA DE FECHA: si la fecha más común existe, 
         * marca el resto como excepciones de fecha.
         * @param {Array<Object>} dataArray - Array de resultados de extracciones exitosas.
         * @returns {Object} Un objeto con los resultados del análisis de la fecha.
         */
        function detectMajorityDateAndExceptions(dataArray) {
            const dateCounts = {};

            // 1. Contar frecuencias de fechas (usando el formato normalizado DD/MM/AAAA)
            dataArray.forEach(entry => {
                const extractedDate = entry.data.date;
                // 'FECHA_NO_ENCONTRADA' si el campo 'date' no existe o está vacío
                const normalizedDate = extractedDate ? formatDateShort(extractedDate) : 'FECHA_NO_ENCONTRADA';
                
                // Añadir propiedades de control al objeto de datos
                entry.normalizedDate = normalizedDate; 
                entry.isDateException = false; 
                entry.observation_date = entry.observation_date || ''; // Inicializar campo de observación vacío, manteniendo el existente si ya tiene

                dateCounts[normalizedDate] = (dateCounts[normalizedDate] || 0) + 1;
            });

            // Si no hay extracciones exitosas, no podemos calcular nada.
            if (dataArray.length === 0) return { majorityDate: null, nonMajorityCount: 0, totalExtracted: 0 };

            // 2. Encontrar la fecha mayoritaria
            let majorityDate = null;
            let maxCount = 0; // Número de archivos exitosos que coinciden con la fecha más común.

            for (const date in dateCounts) {
                if (dateCounts[date] > maxCount) {
                    maxCount = dateCounts[date];
                    majorityDate = date;
                }
            }

            // 3. Marcar excepciones y contar las que no coinciden con la mayoría
            let nonMajorityCount = 0;
            
            if (majorityDate) {
                dataArray.forEach(entry => {
                    // Si la fecha normalizada NO coincide con la fecha mayoritaria O si la fecha es 'FECHA_NO_ENCONTRADA'
                    if (entry.normalizedDate !== majorityDate) {
                        entry.isDateException = true;
                        nonMajorityCount++;
                    } else {
                        entry.isDateException = false;
                    }
                });
            }
            
            return { 
                majorityDate, 
                nonMajorityCount, 
                majorityCount: maxCount,
                totalExtracted: dataArray.length
            };
        }


        /**
         * Dibuja los resultados extraídos en la interfaz, incluyendo la separación de duplicados y excepciones de fecha.
         */
        function displayResults(dataArray, duplicationWarning = "", dateLogicResult) {
            dataList.innerHTML = ''; 
            selectAllResultsCheckbox.checked = false; // Desmarcar el chulo principal de resultados
            
            if (dataArray.length === 0) {
                 infoMessage.textContent = "No se pudo extraer información de ninguna imagen.";
                 setUIState(false, false, false);
                 return;
            } 
            
            // Mensaje de Información de Lógica de Fecha (Actualizado para CONTEO)
            let dateInfoText = '';
            const isDateSelected = getSelectedFields().includes('date');
            
            // Texto para archivos totales y extraídos
            const totalFiles = imageUpload.files.length;
            const extractedFiles = dateLogicResult.totalExtracted || dataArray.length;
            
            let filesInfo = `Extracción completada para ${extractedFiles} de ${totalFiles} archivo(s).`;


            if (!isDateSelected) {
                 dateInfoText = " (ADVERTENCIA: Detección de consistencia de fecha desactivada, no se seleccionó el campo 'Fecha').";
            } else if (dateLogicResult.totalExtracted > 0) {
                // NOTA: dateLogicResult.nonMajorityCount ya incluye fallas de parseo de fecha y las que no coinciden.
                dateInfoText = ` (Fecha Mayoritaria: ${dateLogicResult.majorityDate}, encontrada en ${dateLogicResult.majorityCount} de ${extractedFiles} extracciones. Total de excepciones/fallas de fecha: ${dateLogicResult.nonMajorityCount}).`;

            } else {
                dateInfoText = ` (No se pudo extraer ninguna fecha para verificar la consistencia).`;
            }

            infoMessage.textContent = `${filesInfo}${duplicationWarning}${dateInfoText}`;
            
            // Ordenar: Excepciones (Duplicados o Fecha) al final, Únicos/Normales primero
            dataArray.sort((a, b) => {
                const isAException = a.isDuplicate || a.isDateException;
                const isBException = b.isDuplicate || b.isDateException;
                return (isAException ? 1 : 0) - (isBException ? 1 : 0);
            });

            let isNormalGroupDisplayed = false;
            let isExceptionGroupDisplayed = false;

            dataArray.forEach((entry, index) => {
                const data = entry.data;
                const fileName = entry.fileName;
                const isDuplicate = entry.isDuplicate || false;
                const isDateException = entry.isDateException || false; // CRÍTICO: Usar esta bandera
                const isAnyException = isDuplicate || isDateException;

                // Definir colores y encabezados de grupo
                const cardClasses = isAnyException 
                    ? 'bg-yellow-50 border-yellow-400' 
                    : 'bg-white border-gray-200';
                
                // Añadir encabezados de grupo dinámicamente
                if (!isAnyException && !isNormalGroupDisplayed) {
                    isNormalGroupDisplayed = true;
                    const uniqueHeader = document.createElement('h3');
                    uniqueHeader.className = 'text-lg font-bold text-gray-700 mt-4 mb-2 border-b border-gray-300 pb-1';
                    uniqueHeader.textContent = "Comprobantes Únicos y con Fecha Mayoritaria";
                    dataList.appendChild(uniqueHeader);
                } else if (isAnyException && !isExceptionGroupDisplayed) {
                    isExceptionGroupDisplayed = true;
                    const exceptionHeader = document.createElement('h3');
                    exceptionHeader.className = 'text-lg font-bold text-red-600 mt-8 mb-2 border-b-2 border-red-300 pb-1';
                    exceptionHeader.textContent = "Excepciones Detectadas (Duplicados y/o Fecha Diferente)";
                    dataList.appendChild(exceptionHeader);
                }
                
                // Contenedor principal de la tarjeta de archivo
                const fileCard = document.createElement('div');
                fileCard.className = `p-4 rounded-lg shadow-xl border ${cardClasses}`;

                // Encabezado y Checkbox para toda la fila
                const headerDiv = document.createElement('div');
                headerDiv.className = 'flex items-center justify-between pb-2 mb-2 border-b border-gray-100';

                // Checkbox (Chulo) para seleccionar esta fila de datos
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `file-entry-${index}`;
                checkbox.checked = !isAnyException; // Marcar únicos/normales por defecto
                checkbox.className = 'w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 cursor-pointer result-select-item';
                checkbox.setAttribute('data-index', index); // Index corresponde a la posición en el array ORDENADO

                const label = document.createElement('label');
                label.htmlFor = `file-entry-${index}`;
                
                // Indicadores de Excepción
                let indicators = '';
                if (isDuplicate) {
                    indicators += `<span class="text-xs font-semibold text-red-600 bg-red-100 px-2 py-0.5 rounded mr-2">DUPLICADO</span>`;
                }
                if (isDateException) {
                    indicators += `<span class="text-xs font-semibold text-orange-600 bg-orange-100 px-2 py-0.5 rounded mr-2">FECHA APARTE</span>`;
                }

                label.className = 'ml-3 flex-1 text-base font-bold text-gray-700 cursor-pointer truncate';
                label.innerHTML = `${indicators} Archivo: ${fileName}`;
                
                headerDiv.appendChild(checkbox);
                headerDiv.appendChild(label);
                fileCard.appendChild(headerDiv);

                // Contenido de la fila de datos (solo muestra los campos extraídos)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'space-y-1 text-sm';
                
                Object.keys(data).forEach(key => {
                    const labelText = FIELD_METADATA[key] ? FIELD_METADATA[key].label : key; 
                    let value = data[key];

                    // Formatear la fecha para la visualización en la interfaz también
                    if (key === 'date') {
                        value = formatDateShort(value);
                    }
                    
                    const dataLine = document.createElement('p');
                    dataLine.innerHTML = `<span class="font-semibold text-gray-500">${labelText}:</span> <span class="text-gray-900 font-medium">${value}</span>`;
                    contentDiv.appendChild(dataLine);
                });

                fileCard.appendChild(contentDiv);
                
                // --- CAMPO DE ENTRADA DE FECHA DE OBSERVACIÓN (SOLO SI ES EXCEPCIÓN DE FECHA) ---
                if (isDateException) {
                    const manualDateDiv = document.createElement('div');
                    manualDateDiv.className = 'mt-4 pt-3 border-t border-yellow-200 flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4';
                    
                    const dateLabel = document.createElement('label');
                    dateLabel.htmlFor = `obs-date-${index}`;
                    dateLabel.className = 'font-bold text-sm text-yellow-800 flex-shrink-0';
                    dateLabel.textContent = 'Fecha de Observación (Manual):';
                    
                    const dateInput = document.createElement('input');
                    dateInput.type = 'date'; // Usar input type="date" para formato YYYY-MM-DD
                    dateInput.id = `obs-date-${index}`;
                    dateInput.className = 'p-2 border border-yellow-500 bg-yellow-50 rounded-md shadow-sm text-sm w-full sm:w-auto';
                    
                    // Si ya teníamos una fecha guardada (por re-renderizado), la cargamos
                    if (entry.observation_date) {
                        dateInput.value = entry.observation_date; 
                    }
                    
                    dateInput.addEventListener('change', (e) => {
                        // Guardar la fecha en formato YYYY-MM-DD (estándar de input type="date")
                        entry.observation_date = e.target.value; 
                    });

                    manualDateDiv.appendChild(dateLabel);
                    manualDateDiv.appendChild(dateInput);
                    fileCard.appendChild(manualDateDiv);
                }
                // --------------------------------------------------------------------------------

                dataList.appendChild(fileCard);
            });

            // Agregar listener para habilitar/deshabilitar el botón de descarga
            dataList.addEventListener('change', updateDownloadButtonState);
            updateDownloadButtonState();
            setUIState(false, false, true); // Oculta carga, muestra resultados
        }

        // Actualiza el estado del botón de descarga basado en los chulos seleccionados
        function updateDownloadButtonState() {
            const checkedCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item:checked');
            downloadButton.disabled = checkedCheckboxes.length === 0;
            
            // Actualizar el estado del chulo principal de resultados
            const totalCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item').length;
            selectAllResultsCheckbox.checked = totalCheckboxes > 0 && checkedCheckboxes.length === totalCheckboxes;
        }

        // --- Manejadores de Eventos ---

        // Selector/Deselector de todos los CAMPOS
        selectAllFieldsCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            fieldSelectionDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        });

        // Selector/Deselector de todas las FILAS DE RESULTADOS
        selectAllResultsCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            dataList.querySelectorAll('input[type="checkbox"].result-select-item').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            updateDownloadButtonState(); // Actualizar el estado del botón de descarga
        });
        
        // Seleccionar solo las excepciones de fecha
        selectDateExceptionsButton.addEventListener('click', () => {
            // Deseleccionar todo primero
            dataList.querySelectorAll('input[type="checkbox"].result-select-item').forEach(checkbox => {
                checkbox.checked = false;
            });

            // Iterar sobre los datos internos (que ya están ordenados y tienen las banderas)
            allExtractedData.forEach((entry, index) => {
                if (entry.isDateException) {
                    // Buscar el checkbox correspondiente por índice
                    // Nota: Usamos `data-index` que corresponde a la posición en allExtractedData
                    const checkbox = document.querySelector(`input[type="checkbox"].result-select-item[data-index="${index}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
            updateDownloadButtonState();
        });


        // Listener para los chulos individuales de campos
        fieldSelectionDiv.addEventListener('change', () => {
             // Actualizar el chulo principal de campos
            const allItems = fieldSelectionDiv.querySelectorAll('input[type="checkbox"]').length;
            const checkedItems = fieldSelectionDiv.querySelectorAll('input[type="checkbox"]:checked').length;
            selectAllFieldsCheckbox.checked = allItems > 0 && checkedItems === allItems;
        });

        // Habilita el botón de proceso y actualiza el contador al seleccionar archivos
        imageUpload.addEventListener('change', () => {
            const fileCount = imageUpload.files.length;
            fileCountSpan.textContent = fileCount;
            processButton.disabled = fileCount === 0;
            
            setUIState(false, false, false);
            errorArea.classList.add('hidden');
            allExtractedData = []; // Resetear datos
            infoMessage.textContent = fileCount > 0 ? "Listo para procesar." : "";
        });

        // Lógica principal de extracción al hacer clic en el botón
        processButton.addEventListener('click', async () => {
            const files = Array.from(imageUpload.files);
            if (files.length === 0) return;
            const selectedFields = getSelectedFields();
            const totalFilesCount = files.length; // Total de archivos subidos

            // Validación de campos seleccionados
            if (selectedFields.length === 0) {
                infoMessage.textContent = "ERROR: Por favor, selecciona al menos un campo a extraer.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return;
            } else {
                 infoMessage.classList.remove('text-red-600', 'font-bold');
                 infoMessage.classList.add('text-gray-500');
                 infoMessage.textContent = "Procesando...";
            }

            setUIState(true, false, false); 
            errorArea.classList.add('hidden');
            allExtractedData = []; 
            let successCount = 0;
            let errorOccurred = false;

            // Procesamiento secuencial
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                loadingMessage.textContent = `Analizando imagen ${i + 1} de ${files.length}: ${file.name}...`;

                try {
                    const data = await processSingleImage(file);
                    
                    // Almacenar el resultado exitoso e inicializar banderas/campos
                    allExtractedData.push({
                        fileName: file.name,
                        data: data,
                        isDuplicate: false, // Inicializado
                        isDateException: false, // Inicializado
                        observation_date: '' // Inicializado
                    });
                    successCount++;

                } catch (error) {
                    console.error(`Error al procesar ${file.name}:`, error);
                    errorOccurred = true;
                    // Mostrar error en la interfaz sin detener el proceso
                    const errorText = error.message || "Error desconocido.";
                    errorArea.innerHTML = `Ocurrió un error al procesar "${file.name}": <span class="font-normal">${errorText}</span>. Revisa la consola para más detalles.`;
                    errorArea.classList.remove('hidden');
                }
            }
            
            let duplicationWarning = "";
            let dateLogicResult = { majorityDate: null, nonMajorityCount: 0, majorityCount: 0, totalExtracted: 0 };

            if (successCount > 0) {
                
                // --- LÓGICA DE DETECCIÓN DE DUPLICADOS (Nº Comprobante) ---
                const CHECK_FIELD_KEY_DUP = 'receipt_number';
                const isDuplicationCheckPossible = selectedFields.includes(CHECK_FIELD_KEY_DUP);

                if (isDuplicationCheckPossible) {
                    const receiptNumbers = new Set();
                    // Primero identificar duplicados
                    allExtractedData.forEach(entry => {
                        const receiptNumber = entry.data[CHECK_FIELD_KEY_DUP];
                        if (receiptNumber && receiptNumbers.has(receiptNumber)) {
                            entry.isDuplicate = true;
                        } else if (receiptNumber) {
                            receiptNumbers.add(receiptNumber);
                        }
                    });
                } else {
                    duplicationWarning = " (ADVERTENCIA: No se verificó duplicidad porque el 'Nº Comprobante' no fue seleccionado).";
                }
                // --- FIN LÓGICA DE DUPLICADOS ---

                // --- LÓGICA DE DETECCIÓN DE CONSISTENCIA POR FECHA (BASADA EN CONTEO) ---
                if (selectedFields.includes('date')) {
                    // Solo enviamos los archivos que se extrajeron exitosamente
                    dateLogicResult = detectMajorityDateAndExceptions(allExtractedData);
                }
                // --- FIN LÓGICA DE FECHA ---
            }


            if (successCount === 0) {
                setUIState(false, true, false); 
            } else {
                displayResults(allExtractedData, duplicationWarning, dateLogicResult);
            }
            // Asegurarse de quitar el estado de carga después de todo.
            setUIState(false, errorOccurred, allExtractedData.length > 0);
        });

        // --- Lógica de Descarga de Libro XLSX Agrupado por Destinatario ---
        downloadButton.addEventListener('click', () => {
            const checkedCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item:checked');
            if (checkedCheckboxes.length === 0) {
                infoMessage.textContent = "ERROR: Selecciona al menos una fila para exportar.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return;
            }

            const selectedFields = getSelectedFields(); 
            const hasDateSelected = selectedFields.includes('date');
            const hasRecipientSelected = selectedFields.includes('recipient');

            if (selectedFields.length === 0) {
                infoMessage.textContent = "ERROR: No hay campos seleccionados para exportar. Selecciona los campos en la sección 1.5.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return;
            } else {
                 infoMessage.classList.remove('text-red-600', 'font-bold');
                 infoMessage.classList.add('text-gray-500');
            }
            
            // Función interna para obtener la estructura de datos para SheetJS (Array of Arrays)
            const getSheetDataRow = (entry, selectedFields, hasDateSelected, hasRecipientSelected) => {
                
                const rowData = [];
                
                selectedFields.forEach(key => {
                    let value = entry.data[key] || ""; 
                    
                    if (key === 'date' && hasDateSelected) {
                        // 1. Añadir la Fecha extraída (DD/MM/AAAA)
                        value = formatDateShort(value); 
                        rowData.push(value); // Fecha extraída (formateada)
                        
                        // 2. Añadir la Fecha de Observación (Manual) justo después
                        let obsDate = '';
                        if (entry.isDateException && entry.observation_date) { 
                            // Convertir de YYYY-MM-DD (input date) a DD/MM/AAAA (para Excel)
                            try {
                                const [year, month, day] = entry.observation_date.split('-');
                                obsDate = `${day}/${month}/${year}`;
                            } catch (e) {
                                obsDate = entry.observation_date; // Fallback
                            }
                        }
                        rowData.push(obsDate); 
                    } else {
                        // Para el resto de campos (solo el valor)
                        rowData.push(value);
                    }
                });
                
                // C. Campo de Agrupación (Destinatario) si NO FUE seleccionado originalmente
                if (!hasRecipientSelected) {
                    rowData.push(entry.data.recipient || 'DESTINATARIO_NO_EXTRAÍDO');
                }

                // D. Datos de metadatos (al final)
                rowData.push(
                    entry.fileName,
                    entry.isDuplicate ? "Sí" : "No",                      
                    entry.isDateException ? "Sí" : "No"                 
                );
                
                return rowData;
            };

            // Función para obtener los encabezados
            const getSheetHeaders = (selectedFields, hasDateSelected, hasRecipientSelected) => {
                const headers = [];
                selectedFields.forEach(key => {
                    headers.push(FIELD_METADATA[key].label);
                    if (key === 'date' && hasDateSelected) {
                        // CRÍTICO: Añadir encabezado para el campo de observación
                        headers.push("Fecha de Observación"); 
                    }
                });
                if (!hasRecipientSelected) {
                     headers.push(FIELD_METADATA.recipient.label); 
                }
                headers.push("Archivo", "Es Duplicado", "Es Excepción de Fecha");
                return headers;
            }


            // 1. Obtener datos seleccionados
            const selectedData = [];
            checkedCheckboxes.forEach(checkbox => {
                const index = parseInt(checkbox.getAttribute('data-index'));
                const entry = allExtractedData.find((_, i) => i === index);
                if (entry) {
                    selectedData.push(entry);
                }
            });
            
            // 2. Agrupar por destinatario
            const groups = selectedData.reduce((acc, entry) => {
                // Usar el valor extraído o un valor por defecto
                const recipientName = entry.data.recipient || 'DESTINATARIO_NO_EXTRAÍDO';
                // Sanitizar el nombre para usarlo como nombre de pestaña (max 31 chars, sin caracteres inválidos)
                let safeRecipientName = recipientName
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Quitar tildes
                    .replace(/[\\/?*[\]:]/g, '_') // Quitar caracteres inválidos para nombre de hoja de Excel
                    .trim().toUpperCase() 
                    .replace(/\s+/g, '_'); // Reemplazar espacios por guiones bajos
                
                // Limitar la longitud a 30 caracteres (Excel tiene un límite de 31)
                safeRecipientName = safeRecipientName.substring(0, 30) || 'SIN_NOMBRE';
                
                if (!acc[safeRecipientName]) {
                    acc[safeRecipientName] = [];
                }
                acc[safeRecipientName].push(entry);
                return acc;
            }, {});

            // 3. Generar Libro de Excel (Workbook)
            const workbook = XLSX.utils.book_new();
            let groupCount = 0;

            for (const safeRecipientName in groups) {
                if (Object.hasOwnProperty.call(groups, safeRecipientName)) {
                    const recipientData = groups[safeRecipientName];
                    groupCount++;

                    // Prepara el array de arrays (AoA) para SheetJS
                    const sheetData = [];

                    // 1. Añadir Encabezados
                    const headers = getSheetHeaders(selectedFields, hasDateSelected, hasRecipientSelected);
                    sheetData.push(headers);
                    
                    // 2. Añadir Filas de Datos
                    recipientData.forEach(entry => {
                        const rowData = getSheetDataRow(entry, selectedFields, hasDateSelected, hasRecipientSelected);
                        sheetData.push(rowData);
                    });

                    // 3. Crear Worksheet a partir del array de arrays
                    const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
                    
                    // 4. Añadir Worksheet al Workbook
                    XLSX.utils.book_append_sheet(workbook, worksheet, safeRecipientName);
                }
            }

            // 4. Escribir el Workbook y descargar
            if (groupCount > 0) {
                infoMessage.textContent = `Generando libro de Excel con ${groupCount} hoja(s)...`;
                
                try {
                    // Esta función maneja la conversión a XLSX y la descarga automáticamente
                    XLSX.writeFile(workbook, `comprobantes_agrupados_${Date.now()}.xlsx`);
                    infoMessage.textContent = `¡Descarga del libro de Excel (.xlsx) con ${groupCount} hojas (una por destinatario) completada!`;
                } catch (error) {
                    console.error("Error al generar el archivo XLSX:", error);
                    infoMessage.textContent = "ERROR al generar el archivo XLSX. Ver consola.";
                    infoMessage.classList.add('text-red-600', 'font-bold');
                }
            } else {
                infoMessage.textContent = "ERROR: No hay datos seleccionados para generar el libro XLSX.";
                infoMessage.classList.add('text-red-600', 'font-bold');
            }
        });

    </script>
</body>
</html>

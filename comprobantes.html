<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extractor Inteligente de Comprobantes (Libro XLSX)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.5/dist/xlsx.full.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Variables globales para Firebase (accesibles desde el script principal)
        window.firebase = { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, getFirestore, doc, getDoc, setDoc };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        /* Estilos generales para un aspecto limpio */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }
        /* Estilo para el spinner de carga */
        .spinner {
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Estilo para el botón con menú desplegable */
        #downloadButtonContainer {
            position: relative;
        }
        #downloadMenu {
            position: absolute;
            bottom: 100%; /* Coloca el menú justo encima del botón */
            left: 0;
            right: 0;
            margin-bottom: 8px; /* Pequeño espacio entre botón y menú */
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center p-4">

    <div class="w-full max-w-2xl bg-white shadow-2xl rounded-xl p-8 space-y-6">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center border-b pb-4">
            Sistema de Extracción de Comprobantes (Múltiple)
        </h1>

        <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-200">
            <label for="imageUpload" class="block text-lg font-semibold text-blue-800 mb-2">
                1. Adjuntar Comprobantes (Múltiples Archivos)
            </label>
            <input type="file" id="imageUpload" accept="image/*" multiple class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-100 file:text-blue-700
                hover:file:bg-blue-200"
            />
            <button id="processButton" class="w-full mt-4 py-2 px-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md disabled:opacity-50" disabled>
                Extraer Datos de <span id="fileCount">0</span> Archivos
            </button>
        </div>

        <div class="bg-indigo-50 p-4 rounded-lg border-2 border-indigo-200">
            <label class="block text-lg font-semibold text-indigo-800 mb-2">
                1.5. Seleccionar Campos a Extraer
            </label>
            <p class="text-sm text-indigo-600 mb-3 font-medium">
                Nota: Los campos **Fecha** y **Nombre del Destinatario** son importantes para las reglas de consistencia y agrupación.
            </p>
            <div class="flex items-center mb-4 pb-2 border-b border-indigo-300">
                <input type="checkbox" id="selectAllFields" class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                <label for="selectAllFields" class="ml-2 text-sm font-bold text-indigo-900 cursor-pointer">
                    Seleccionar/Deseleccionar Todos los Campos
                </label>
            </div>
            <div id="fieldSelection" class="flex flex-wrap gap-4">
                </div>
        </div>


        <div id="loadingArea" class="hidden text-center p-4 bg-yellow-100 rounded-lg">
            <div class="flex items-center justify-center space-x-2">
                <div class="spinner border-4 border-t-4 border-gray-200 h-6 w-6 rounded-full"></div>
                <span id="loadingMessage" class="text-yellow-800 font-medium">Iniciando sistema...</span></span>
            </div>
        </div>
        <div id="errorArea" class="hidden text-center p-4 bg-red-100 text-red-700 rounded-lg font-medium">
            Ocurrió un error. Por favor, revisa la consola para más detalles.
        </div>
        
        <div id="resultsArea" class="hidden space-y-4 bg-green-50 p-6 rounded-xl border-2 border-green-200">
            <h2 class="text-xl font-bold text-green-800 mb-4">2. Resultados Consolidados <span class="text-sm font-normal text-gray-600">(Selecciona qué filas exportar)</span></h2>
            
            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 mb-4 pb-2 border-b border-green-300">
                <div class="flex items-center">
                    <input type="checkbox" id="selectAllResults" class="w-4 h-4 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 cursor-pointer result-select-master">
                    <label for="selectAllResults" class="ml-2 text-base font-bold text-green-800 cursor-pointer">
                        Seleccionar Todas
                    </label>
                </div>
                <button id="selectDateExceptionsButton" class="text-sm font-semibold py-1 px-3 rounded-full bg-orange-100 text-orange-800 hover:bg-orange-200 transition duration-150 shadow-md">
                    Seleccionar Solo Excepciones de Fecha
                </button>
            </div>
            
            <div id="dataList" class="space-y-4">
                </div>

            <div id="downloadButtonContainer" class="mt-6">
                <div id="downloadMenu" class="hidden bg-white rounded-lg shadow-xl ring-1 ring-black ring-opacity-5 divide-y divide-gray-100">
                    <button id="downloadGrouped" class="w-full text-left px-4 py-3 text-sm font-medium text-gray-700 hover:bg-green-100 transition duration-150 rounded-t-lg">
                        Descargar Agrupado por Destinatario (Múltiples Hojas)
                    </button>
                    <button id="downloadConsolidated" class="w-full text-left px-4 py-3 text-sm font-medium text-gray-700 hover:bg-green-100 transition duration-150 rounded-b-lg">
                        Descargar Todo en una Sola Hoja (Consolidado)
                    </button>
                </div>
                
                <button id="toggleDownloadMenuButton" class="w-full py-3 px-4 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-lg disabled:opacity-50" disabled>
                    Descargar Libro de Excel (XLSX)
                </button>
            </div>
        </div>
        
        <p id="infoMessage" class="text-sm text-gray-500 text-center">Inicializando base de datos...</p>
    </div>

    <script>
        // --- Variables Globales y Configuración de Gemini / Firebase ---
        const imageUpload = document.getElementById('imageUpload');
        const processButton = document.getElementById('processButton');
        const toggleDownloadMenuButton = document.getElementById('toggleDownloadMenuButton');
        const downloadMenu = document.getElementById('downloadMenu');
        const downloadGroupedButton = document.getElementById('downloadGrouped');
        const downloadConsolidatedButton = document.getElementById('downloadConsolidated');
        const loadingArea = document.getElementById('loadingArea');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorArea = document.getElementById('errorArea');
        const resultsArea = document.getElementById('resultsArea');
        const dataList = document.getElementById('dataList');
        const fileCountSpan = document.getElementById('fileCount');
        const infoMessage = document.getElementById('infoMessage');
        const fieldSelectionDiv = document.getElementById('fieldSelection'); 
        const selectAllFieldsCheckbox = document.getElementById('selectAllFields'); 
        const selectAllResultsCheckbox = document.getElementById('selectAllResults'); 
        const selectDateExceptionsButton = document.getElementById('selectDateExceptionsButton');
        
        // *****************************************************************************
        // *** CONFIGURACIÓN MANDATORIA ************************************************
        // *****************************************************************************
        const apiKey = "AIzaSyBZ37K5guckjv-I-OgpRFH5v_jj8nsTyH8"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        let db = null;
        let auth = null;
        let userId = 'anon';
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // ** MODIFICACIÓN CLAVE: Manejo de la configuración de Firebase. **
        // Si la configuración no existe (ejecutando desde GitHub), se usa un objeto simulado 
        // para que la inicialización no falle, permitiendo que la app principal funcione.
        const firebaseConfig = typeof __firebase_config !== 'undefined' 
            ? JSON.parse(__firebase_config) 
            : { apiKey: 'MOCK_KEY_FOR_STANDALONE' }; 
            
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Estado del sistema
        let isAuthReady = false;

        // {fileName, file, hash, data, isDuplicate: boolean, isDateException: boolean, observation_date: string, isCached: boolean}
        let allExtractedData = []; 
        
        // Mapeo de meses en español (para la conversión de fecha)
        const MONTH_MAP = {
            'ene': 0, 'feb': 1, 'mar': 2, 'abr': 3, 'may': 4, 'jun': 5, 
            'jul': 6, 'ago': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dic': 11,
            'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5, 
            'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
        };


        // Metadata de los campos disponibles (SOLO para la extracción de la IA)
        const FIELD_METADATA = {
            value: { 
                label: 'Valor de la transferencia', 
                description: "El valor de la transferencia con el símbolo de moneda, por ejemplo $78.465." 
            },
            receipt_number: { 
                label: 'Nº Comprobante', 
                description: "El número de comprobante completo, por ejemplo 0000093600." 
            },
            date: { 
                label: 'Fecha', 
                description: "La fecha de la transferencia, por ejemplo 10 Oct 2025." 
            },
            time: { 
                label: 'Hora', 
                description: "La hora de la transferencia, por ejemplo 11:36 a. m.." 
            },
            recipient: {
                label: 'Nombre del Destinatario',
                description: "El nombre completo o razón social del destinatario de la transferencia."
            }
        };

        // --- INICIALIZACIÓN DE FIREBASE ---
        async function initFirebase() {
            // ** VERIFICACIÓN DE CONFIGURACIÓN MODIFICADA **
            if (firebaseConfig.apiKey === 'MOCK_KEY_FOR_STANDALONE') {
                console.warn("ADVERTENCIA: Configuración de Firebase no detectada. La caché de Firestore está DESACTIVADA, pero la extracción con Gemini funcionará.");
                isAuthReady = true;
                infoMessage.textContent = "Sistema de Extracción listo (Caché desactivada).";
                processButton.disabled = imageUpload.files.length === 0;
                return;
            }

            try {
                const app = window.firebase.initializeApp(firebaseConfig);
                db = window.firebase.getFirestore(app);
                auth = window.firebase.getAuth(app);

                if (initialAuthToken) {
                    await window.firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await window.firebase.signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID();
                isAuthReady = true;
                console.log("Firebase y autenticación inicializados. User ID:", userId);
                infoMessage.textContent = "Sistema listo para recibir archivos y CACHÉ ACTIVADA.";
                processButton.disabled = imageUpload.files.length === 0;

            } catch (error) {
                console.error("Error al inicializar o autenticar Firebase:", error);
                // Si la BD falla, desactivamos la caché pero permitimos que Gemini funcione.
                db = null; 
                isAuthReady = true;
                infoMessage.textContent = "Error de conexión con la base de datos. Caché desactivada.";
            }
        }
        
        // Llamada a la inicialización al cargar la página
        window.onload = () => {
             initFirebase();
             initFieldSelection(); 
        };
        // --- FIN INICIALIZACIÓN DE FIREBASE ---

        // --- FUNCIONES DE CACHÉ FIREBASE ---

        /**
         * Calcula el hash MD5 de un archivo para usarlo como clave de caché.
         * @param {File} file El objeto File.
         * @returns {Promise<string>} El hash MD5.
         */
        function calculateFileHash(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        // Utiliza ArrayBuffer para el cálculo del hash, que es más rápido y estándar para archivos
                        const wordBuffer = CryptoJS.lib.WordArray.create(e.target.result);
                        const hash = CryptoJS.MD5(wordBuffer).toString();
                        resolve(hash);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        /**
         * Ruta de la colección de caché (datos públicos para este app)
         */
        function getCacheDocRef(hash) {
            // Utilizamos la ruta pública /artifacts/{appId}/public/data/extraction_cache
            return window.firebase.doc(db, "artifacts", appId, "public", "data", "extraction_cache", hash);
        }

        /**
         * Busca la extracción de un archivo en la caché de Firestore.
         * @param {string} hash El hash MD5 del archivo.
         * @returns {Promise<Object|null>} El objeto de datos extraídos o null.
         */
        async function getCachedExtraction(hash) {
            // Solo intentamos buscar en la caché si el DB está inicializado y listo.
            if (!db) return null; 
            try {
                const docRef = getCacheDocRef(hash);
                const docSnap = await window.firebase.getDoc(docRef);
                
                if (docSnap.exists()) {
                    console.log(`[CACHÉ HIT] Extracción encontrada para hash: ${hash}`);
                    return docSnap.data().extractionData;
                } else {
                    console.log(`[CACHÉ MISS] No hay extracción para hash: ${hash}`);
                    return null;
                }
            } catch (error) {
                console.error("Error al buscar en caché:", error);
                return null;
            }
        }

        /**
         * Guarda una extracción de la IA en la caché de Firestore.
         * @param {string} hash El hash MD5 del archivo.
         * @param {Object} data Los datos JSON extraídos por la IA.
         */
        async function saveExtractionToCache(hash, data) {
            // Solo guardamos si el DB está inicializado y listo.
            if (!db) return; 
            try {
                const docRef = getCacheDocRef(hash);
                await window.firebase.setDoc(docRef, {
                    hash: hash,
                    extractionData: data,
                    timestamp: new Date().toISOString()
                }, { merge: true });
                console.log(`[CACHÉ WRITE] Extracción guardada para hash: ${hash}`);
            } catch (error) {
                console.error("Error al guardar en caché:", error);
            }
        }

        // --- FIN FUNCIONES DE CACHÉ FIREBASE ---

        /**
         * Intenta convertir una cadena de fecha extraída (ej: '10 Oct 2025' o '7-oct-25') 
         * a formato corto DD/MM/AAAA (ej: '10/10/2025').
         */
        function formatDateShort(dateString) {
            if (!dateString) return "FECHA_NO_ENCONTRADA";
            
            const parts = dateString.trim().split(/[\s\-/]+/);
            
            if (parts.length < 3) return dateString; 

            let day = parseInt(parts[0]);
            let monthStr = parts[1].toLowerCase().substring(0, 3);
            let year = parseInt(parts[2]);

            const monthIndex = MONTH_MAP[monthStr];

            if (isNaN(day) || monthIndex === undefined || isNaN(year)) {
                return dateString;
            }

            if (year < 100) {
                year = 2000 + year; 
            }

            const formattedDay = String(day).padStart(2, '0');
            const formattedMonth = String(monthIndex + 1).padStart(2, '0');
            
            return `${formattedDay}/${formattedMonth}/${year}`;
        }
        
        // Inicializa los checkboxes de selección de campos (Marcar Fecha, Comprobante y Destinatario por defecto)
        function initFieldSelection() {
            fieldSelectionDiv.innerHTML = '';
            const defaultCheckedFields = ['date', 'receipt_number', 'recipient']; 
            
            Object.keys(FIELD_METADATA).forEach(key => {
                const field = FIELD_METADATA[key];
                
                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-center';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `field-${key}`;
                checkbox.value = key;
                checkbox.checked = defaultCheckedFields.includes(key); 
                checkbox.className = 'w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer field-select-item';

                const label = document.createElement('label');
                label.htmlFor = `field-${key}`;
                label.className = 'ml-2 text-sm font-medium text-gray-700 cursor-pointer';
                label.textContent = field.label;

                wrapper.appendChild(checkbox);
                wrapper.appendChild(label);
                fieldSelectionDiv.appendChild(wrapper);
            });
            const allItems = Object.keys(FIELD_METADATA).length;
            selectAllFieldsCheckbox.checked = allItems === defaultCheckedFields.length; 
        }

        // Obtiene los campos seleccionados (las claves del JSON)
        function getSelectedFields() {
            const selected = [];
            fieldSelectionDiv.querySelectorAll('input[type="checkbox"].field-select-item:checked').forEach(checkbox => {
                selected.push(checkbox.value);
            });
            return selected;
        }

        /**
         * Convierte el archivo a una cadena Base64 PURA (sin prefijo) para la API.
         * @param {File} file El objeto File.
         * @returns {Promise<string>} La cadena Base64.
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    try {
                        const base64Data = reader.result.split(',')[1];
                        if (base64Data) {
                            resolve(base64Data);
                        } else {
                            reject(new Error("Error al obtener datos Base64. Formato de archivo inválido."));
                        }
                    } catch (e) {
                         reject(new Error("Error de codificación Base64: " + e.message));
                    }
                };
                reader.onerror = error => reject(error);
            });
        }
        
        // Muestra u oculta elementos de la interfaz
        function setUIState(isLoading, isError, resultsVisible) {
            loadingArea.classList.toggle('hidden', !isLoading);
            // El botón ya no depende de isAuthReady porque la inicialización tiene fallback
            processButton.disabled = isLoading || imageUpload.files.length === 0; 
            errorArea.classList.toggle('hidden', !isError);
            resultsArea.classList.toggle('hidden', !resultsVisible);
            
            toggleDownloadMenuButton.disabled = !resultsVisible; 
            downloadMenu.classList.add('hidden'); 
        }

        /**
         * Llama a la API de Gemini con lógica de reintento (backoff)
         */
        async function fetchWithRetry(url, payload, maxRetries = 5) {
            let delay = 1000;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && i < maxRetries - 1) { 
                        console.warn(`Tasa límite alcanzada. Reintentando en ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }

                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => ({}));
                        const errorMessage = errorBody.error?.message || response.statusText;
                        throw new Error(`Error en la API: ${response.status} - ${errorMessage}`);
                    }
                    
                    return response.json();

                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    console.error("Error temporal. Reintentando...", error);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
            throw new Error("Fallo en la llamada a la API después de múltiples reintentos.");
        }

        /**
         * Procesa una sola imagen usando la API (Si no está en caché)
         * @param {Object} fileEntry - Objeto de datos del archivo con File y Hash
         */
        async function processSingleImageWithCache(fileEntry) {
            const { file, hash } = fileEntry;
            let cachedData = await getCachedExtraction(hash);
            
            if (cachedData) {
                return { data: cachedData, isCached: true };
            }

            // Si falla la caché o no está disponible, llamar a la API
            const selectedFields = getSelectedFields();
            const base64Data = await fileToBase64(file); 

            // 1. Construcción dinámica de Prompts y Schema
            let promptList = [];
            let schemaProperties = {};
            
            selectedFields.forEach(key => {
                const metadata = FIELD_METADATA[key];
                
                let description = metadata.description;
                if (key === 'date') {
                    description += " Devuélvela en el formato DD MES AAAA (ej: 07 Oct 2025)";
                }

                promptList.push(`'${metadata.label}'`); 
                schemaProperties[key] = {
                    type: "STRING",
                    description: description
                };
            });
            
            const fieldsToExtract = promptList.join(', '); 
            
            const systemPrompt = `Eres un asistente de extracción de datos especializado en recibos de transferencia. Tu única tarea es extraer únicamente los campos solicitados y devolverlos estrictamente en formato JSON, sin texto adicional o explicaciones. Los campos a buscar son: ${fieldsToExtract}.`;
            
            const userPrompt = `Por favor, extrae los siguientes datos de la imagen: ${fieldsToExtract}.`;

            // 2. Construcción del payload
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: userPrompt },
                            {
                                inlineData: {
                                    mimeType: file.type, 
                                    data: base64Data
                                }
                            }
                        ]
                    },
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: schemaProperties,
                        propertyOrdering: selectedFields 
                    }
                },
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            const result = await fetchWithRetry(apiUrl, payload);
            
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Respuesta de la IA vacía o mal formada.");
            
            const extractedData = JSON.parse(jsonText);
            
            // GUARDAR en caché si la extracción fue exitosa Y la BD está activa
            if (db) {
                await saveExtractionToCache(hash, extractedData);
            }

            return { data: extractedData, isCached: false };
        }
        
        /**
         * Procesa un array de archivos en lotes concurrentes.
         */
        async function processInBatches(filesWithMetadata, concurrencyLimit) {
            let index = 0;
            let successfulResults = [];
            let errorOccurred = false;
            const totalFiles = filesWithMetadata.length;

            const worker = async () => {
                while (index < totalFiles) {
                    const fileIndex = index; 
                    const fileEntry = filesWithMetadata[fileIndex];
                    index++; 
                    const fileNumber = index; 
                    const fileName = fileEntry.fileName;

                    loadingMessage.textContent = `Analizando imagen ${fileNumber} de ${totalFiles}: ${fileName}...`;

                    try {
                        const { data, isCached } = await processSingleImageWithCache(fileEntry);
                        
                        successfulResults.push({
                            ...fileEntry, // Mantener file, fileName y hash
                            data: data,
                            isDuplicate: false,
                            isDateException: false,
                            observation_date: '',
                            isCached: isCached 
                        });
                        
                        // Mensaje de éxito específico
                        if (isCached) {
                            console.log(`Extracción de ${fileName} cargada desde la CACHÉ. (No se gastó cuota).`);
                        } else {
                            console.log(`Extracción de ${fileName} realizada con la API y guardada en caché.`);
                        }

                    } catch (error) {
                        console.error(`Error al procesar ${fileName}:`, error);
                        errorOccurred = true;
                        const errorText = error.message || "Error desconocido.";
                        errorArea.innerHTML = `Ocurrió un error al procesar "${fileName}": <span class="font-normal">${errorText}</span>. Revisa la consola para más detalles.`;
                        errorArea.classList.remove('hidden');
                        loadingMessage.textContent = `Analizando... (${successfulResults.length} completados de ${totalFiles})`;
                    }
                }
            };

            const workers = [];
            // Ajustar el límite de concurrencia para evitar bloqueos por rate limit de la API, aunque Gemini maneja bien el backoff.
            for (let i = 0; i < concurrencyLimit; i++) {
                workers.push(worker());
            }

            await Promise.all(workers);

            return { successfulResults, errorOccurred };
        }


        /**
         * Implementa la lógica de CONSISTENCIA DE FECHA.
         */
        function detectMajorityDateAndExceptions(dataArray) {
            const dateCounts = {};

            dataArray.forEach(entry => {
                const extractedDate = entry.data.date;
                const normalizedDate = extractedDate ? formatDateShort(extractedDate) : 'FECHA_NO_ENCONTRADA';
                
                entry.normalizedDate = normalizedDate; 
                entry.isDateException = false; 
                entry.observation_date = entry.observation_date || ''; 

                dateCounts[normalizedDate] = (dateCounts[normalizedDate] || 0) + 1;
            });

            if (dataArray.length === 0) return { majorityDate: null, nonMajorityCount: 0, totalExtracted: 0 };

            let majorityDate = null;
            let maxCount = 0; 

            for (const date in dateCounts) {
                if (dateCounts[date] > maxCount) {
                    maxCount = dateCounts[date];
                    majorityDate = date;
                }
            }

            let nonMajorityCount = 0;
            
            if (majorityDate) {
                dataArray.forEach(entry => {
                    if (entry.normalizedDate !== majorityDate) {
                        entry.isDateException = true;
                        nonMajorityCount++;
                    } else {
                        entry.isDateException = false;
                    }
                });
            }
            
            return { 
                majorityDate, 
                nonMajorityCount, 
                majorityCount: maxCount,
                totalExtracted: dataArray.length
            };
        }


        /**
         * Dibuja los resultados extraídos en la interfaz.
         */
        function displayResults(dataArray, duplicationWarning = "", dateLogicResult) {
            dataList.innerHTML = ''; 
            selectAllResultsCheckbox.checked = false; 
            
            if (dataArray.length === 0) {
                 infoMessage.textContent = "No se pudo extraer información de ninguna imagen.";
                 setUIState(false, false, false);
                 return;
            } 
            
            let dateInfoText = '';
            const isDateSelected = getSelectedFields().includes('date');
            
            const totalFiles = imageUpload.files.length;
            const extractedFiles = dateLogicResult.totalExtracted || dataArray.length;
            
            let filesInfo = `Extracción completada para ${extractedFiles} de ${totalFiles} archivo(s).`;

            if (!isDateSelected) {
                 dateInfoText = " (ADVERTENCIA: Detección de consistencia de fecha desactivada, no se seleccionó el campo 'Fecha').";
            } else if (dateLogicResult.totalExtracted > 0) {
                dateInfoText = ` (Fecha Mayoritaria: ${dateLogicResult.majorityDate}, encontrada en ${dateLogicResult.majorityCount} de ${extractedFiles} extracciones. Total de excepciones/fallas de fecha: ${dateLogicResult.nonMajorityCount}).`;

            } else {
                dateInfoText = ` (No se pudo extraer ninguna fecha para verificar la consistencia).`;
            }

            infoMessage.textContent = `${filesInfo}${duplicationWarning}${dateInfoText}`;
            
            // Ordenar: Excepciones (Duplicados o Fecha) al final, Únicos/Normales primero
            dataArray.sort((a, b) => {
                const isAException = a.isDuplicate || a.isDateException;
                const isBException = b.isDuplicate || b.isDateException;
                return (isAException ? 1 : 0) - (isBException ? 1 : 0);
            });

            let isNormalGroupDisplayed = false;
            let isExceptionGroupDisplayed = false;

            dataArray.forEach((entry, index) => {
                const data = entry.data;
                const fileName = entry.fileName;
                const isDuplicate = entry.isDuplicate || false;
                const isDateException = entry.isDateException || false; 
                const isCached = entry.isCached || false;
                const isAnyException = isDuplicate || isDateException;

                // Definir colores y encabezados de grupo
                const cardClasses = isAnyException 
                    ? 'bg-yellow-50 border-yellow-400' 
                    : 'bg-white border-gray-200';
                
                // Añadir encabezados de grupo dinámicamente
                if (!isAnyException && !isNormalGroupDisplayed) {
                    isNormalGroupDisplayed = true;
                    const uniqueHeader = document.createElement('h3');
                    uniqueHeader.className = 'text-lg font-bold text-gray-700 mt-4 mb-2 border-b border-gray-300 pb-1';
                    uniqueHeader.textContent = "Comprobantes Únicos y con Fecha Mayoritaria";
                    dataList.appendChild(uniqueHeader);
                } else if (isAnyException && !isExceptionGroupDisplayed) {
                    isExceptionGroupDisplayed = true;
                    const exceptionHeader = document.createElement('h3');
                    exceptionHeader.className = 'text-lg font-bold text-red-600 mt-8 mb-2 border-b-2 border-red-300 pb-1';
                    exceptionHeader.textContent = "Excepciones Detectadas (Duplicados y/o Fecha Diferente)";
                    dataList.appendChild(exceptionHeader);
                }
                
                // Contenedor principal de la tarjeta de archivo
                const fileCard = document.createElement('div');
                fileCard.className = `p-4 rounded-lg shadow-xl border ${cardClasses}`;

                // Encabezado y Checkbox para toda la fila
                const headerDiv = document.createElement('div');
                headerDiv.className = 'flex items-center justify-between pb-2 mb-2 border-b border-gray-100';

                // Checkbox (Chulo) para seleccionar esta fila de datos
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `file-entry-${index}`;
                checkbox.checked = !isAnyException; // Marcar únicos/normales por defecto
                checkbox.className = 'w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 cursor-pointer result-select-item';
                checkbox.setAttribute('data-index', index); 

                const label = document.createElement('label');
                label.htmlFor = `file-entry-${index}`;
                
                // Indicadores de Estado y Excepción
                let indicators = '';
                if (isCached) {
                    indicators += `<span class="text-xs font-semibold text-indigo-600 bg-indigo-100 px-2 py-0.5 rounded mr-2">CACHÉ/REUTILIZADO</span>`;
                }
                if (isDuplicate) {
                    indicators += `<span class="text-xs font-semibold text-red-600 bg-red-100 px-2 py-0.5 rounded mr-2">DUPLICADO</span>`;
                }
                if (isDateException) {
                    indicators += `<span class="text-xs font-semibold text-orange-600 bg-orange-100 px-2 py-0.5 rounded mr-2">FECHA APARTE</span>`;
                }

                label.className = 'ml-3 flex-1 text-base font-bold text-gray-700 cursor-pointer truncate';
                label.innerHTML = `${indicators} Archivo: ${fileName}`;
                
                headerDiv.appendChild(checkbox);
                headerDiv.appendChild(label);
                fileCard.appendChild(headerDiv);

                // Contenido de la fila de datos (solo muestra los campos extraídos)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'space-y-1 text-sm';
                
                Object.keys(data).forEach(key => {
                    const labelText = FIELD_METADATA[key] ? FIELD_METADATA[key].label : key; 
                    let value = data[key];

                    if (key === 'date') {
                        value = formatDateShort(value);
                    }
                    
                    const dataLine = document.createElement('p');
                    dataLine.innerHTML = `<span class="font-semibold text-gray-500">${labelText}:</span> <span class="text-gray-900 font-medium">${value}</span>`;
                    contentDiv.appendChild(dataLine);
                });

                fileCard.appendChild(contentDiv);
                
                // --- CAMPO DE ENTRADA DE FECHA DE OBSERVACIÓN ---
                if (isDateException) {
                    const manualDateDiv = document.createElement('div');
                    manualDateDiv.className = 'mt-4 pt-3 border-t border-yellow-200 flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4';
                    
                    const dateLabel = document.createElement('label');
                    dateLabel.htmlFor = `obs-date-${index}`;
                    dateLabel.className = 'font-bold text-sm text-yellow-800 flex-shrink-0';
                    dateLabel.textContent = 'Fecha de Observación (Manual):';
                    
                    const dateInput = document.createElement('input');
                    dateInput.type = 'date'; 
                    dateInput.id = `obs-date-${index}`;
                    dateInput.className = 'p-2 border border-yellow-500 bg-yellow-50 rounded-md shadow-sm text-sm w-full sm:w-auto';
                    
                    if (entry.observation_date) {
                        dateInput.value = entry.observation_date; 
                    }
                    
                    dateInput.addEventListener('change', (e) => {
                        entry.observation_date = e.target.value; 
                    });

                    manualDateDiv.appendChild(dateLabel);
                    manualDateDiv.appendChild(dateInput);
                    fileCard.appendChild(manualDateDiv);
                }
                // --------------------------------------------------------------------------------

                dataList.appendChild(fileCard);
            });

            dataList.addEventListener('change', updateDownloadButtonState);
            updateDownloadButtonState();
            setUIState(false, false, true); 
        }

        // Actualiza el estado del botón de descarga basado en los chulos seleccionados
        function updateDownloadButtonState() {
            const checkedCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item:checked');
            toggleDownloadMenuButton.disabled = checkedCheckboxes.length === 0;
            
            const totalCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item').length;
            selectAllResultsCheckbox.checked = totalCheckboxes > 0 && checkedCheckboxes.length === totalCheckboxes;
            
            if (toggleDownloadMenuButton.disabled) {
                downloadMenu.classList.add('hidden');
            }
        }

        /**
         * Lógica central para obtener los datos seleccionados y sus metadatos.
         */
        function getSelectedAndValidatedData() {
            const checkedCheckboxes = dataList.querySelectorAll('input[type="checkbox"].result-select-item:checked');
            if (checkedCheckboxes.length === 0) {
                infoMessage.textContent = "ERROR: Selecciona al menos una fila para exportar.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return [];
            }
            
            const selectedFields = getSelectedFields();
            if (selectedFields.length === 0) {
                infoMessage.textContent = "ERROR: No hay campos seleccionados para exportar. Selecciona los campos en la sección 1.5.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return [];
            } else {
                 infoMessage.classList.remove('text-red-600', 'font-bold');
                 infoMessage.classList.add('text-gray-500');
            }

            const selectedData = [];
            checkedCheckboxes.forEach(checkbox => {
                const index = parseInt(checkbox.getAttribute('data-index'));
                const entry = allExtractedData.find((_, i) => i === index); 
                if (entry) {
                    selectedData.push(entry);
                }
            });
            
            return selectedData;
        }

        /**
         * Función auxiliar para generar la estructura de fila de datos para SheetJS.
         */
        const getSheetDataRow = (entry, selectedFields, hasDateSelected, hasRecipientSelected) => {
            const rowData = [];
            
            selectedFields.forEach(key => {
                let value = entry.data[key] || ""; 
                
                if (key === 'date' && hasDateSelected) {
                    value = formatDateShort(value); 
                    rowData.push(value); 
                    
                    let obsDate = '';
                    if (entry.isDateException && entry.observation_date) { 
                        try {
                            const [year, month, day] = entry.observation_date.split('-');
                            obsDate = `${day}/${month}/${year}`;
                        } catch (e) {
                            obsDate = entry.observation_date; 
                        }
                    }
                    rowData.push(obsDate); 
                } else {
                    rowData.push(value);
                }
            });
            
            // Si el destinatario no se seleccionó, se añade aquí para poder agrupar.
            if (!hasRecipientSelected && selectedFields.includes('recipient')) {
                // Esto no debería ocurrir en el flujo normal, pero lo dejo por si acaso, aunque el campo
                // 'recipient' solo debería aparecer si está en selectedFields.
                rowData.push(entry.data.recipient || 'DESTINATARIO_NO_EXTRAÍDO');
            }

            // Información de Metadatos
            rowData.push(
                entry.fileName,
                entry.isDuplicate ? "Sí" : "No",                      
                entry.isDateException ? "Sí" : "No",
                entry.isCached ? "Sí" : "No",
                entry.hash // <--- Añadir el hash del archivo
            );
            
            return rowData;
        };

        /**
         * Función auxiliar para generar los encabezados de columna.
         */
        const getSheetHeaders = (selectedFields, hasDateSelected, hasRecipientSelected) => {
            const headers = [];
            selectedFields.forEach(key => {
                headers.push(FIELD_METADATA[key].label);
                if (key === 'date' && hasDateSelected) {
                    headers.push("Fecha de Observación"); 
                }
            });
            // Remover la lógica de hasRecipientSelected aquí, ya que solo se añaden los campos seleccionados.

            headers.push("Archivo", "Es Duplicado", "Es Excepción de Fecha", "Reutilizado (Caché)", "Hash MD5 del Archivo"); // <--- Añadir encabezado del Hash
            return headers;
        }


        /**
         * Exporta los datos seleccionados en una sola hoja consolidada.
         */
        function exportConsolidated(data) {
            infoMessage.textContent = `Generando libro de Excel consolidado...`;
            
            const selectedFields = getSelectedFields();
            const hasDateSelected = selectedFields.includes('date');
            const hasRecipientSelected = selectedFields.includes('recipient');

            data.sort((a, b) => {
                const nameA = (a.data.recipient || 'z').toUpperCase();
                const nameB = (b.data.recipient || 'z').toUpperCase();
                return nameA < nameB ? -1 : (nameA > nameB ? 1 : 0);
            });

            const workbook = XLSX.utils.book_new();
            const sheetData = [];

            // Nota: Aquí se usa el parámetro hasRecipientSelected en getSheetHeaders aunque
            // ya no tiene efecto de añadir un campo extra, es solo para mantener la firma.
            const headers = getSheetHeaders(selectedFields, hasDateSelected, hasRecipientSelected);
            sheetData.push(headers);
            
            data.forEach(entry => {
                const rowData = getSheetDataRow(entry, selectedFields, hasDateSelected, hasRecipientSelected);
                sheetData.push(rowData);
            });

            const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
            XLSX.utils.book_append_sheet(workbook, worksheet, "Consolidado");

            try {
                XLSX.writeFile(workbook, `comprobantes_consolidados_${Date.now()}.xlsx`);
                infoMessage.textContent = `¡Descarga del libro de Excel (.xlsx) en una sola hoja completada!`;
                infoMessage.classList.remove('text-red-600', 'font-bold');
            } catch (error) {
                console.error("Error al generar el archivo XLSX consolidado:", error);
                infoMessage.textContent = "ERROR al generar el archivo XLSX consolidado. Ver consola.";
                infoMessage.classList.add('text-red-600', 'font-bold');
            }
        }

        /**
         * Exporta los datos seleccionados agrupados por destinatario (múltiples hojas).
         */
        function exportGrouped(data) {
            infoMessage.textContent = `Generando libro de Excel agrupado por destinatario...`;

            const selectedFields = getSelectedFields();
            const hasDateSelected = selectedFields.includes('date');
            const hasRecipientSelected = selectedFields.includes('recipient'); // Necesario para agrupar

            if (!hasRecipientSelected) {
                infoMessage.textContent = "ERROR: Para la descarga agrupada, el campo 'Nombre del Destinatario' debe estar seleccionado.";
                infoMessage.classList.add('text-red-600', 'font-bold');
                return;
            }

            // 1. Agrupar por destinatario
            const groups = data.reduce((acc, entry) => {
                const recipientName = entry.data.recipient || 'DESTINATARIO_NO_EXTRAÍDO';
                let safeRecipientName = recipientName
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") 
                    .replace(/[\\/?*[\]:]/g, '_') 
                    .trim().toUpperCase() 
                    .replace(/\s+/g, '_');
                
                // Limitar el nombre de la hoja a 30 caracteres
                safeRecipientName = safeRecipientName.substring(0, 30) || 'SIN_NOMBRE';
                
                if (!acc[safeRecipientName]) {
                    acc[safeRecipientName] = [];
                }
                acc[safeRecipientName].push(entry);
                return acc;
            }, {});

            // 2. Generar Libro de Excel (Workbook)
            const workbook = XLSX.utils.book_new();
            let groupCount = 0;

            for (const safeRecipientName in groups) {
                if (Object.hasOwnProperty.call(groups, safeRecipientName)) {
                    const recipientData = groups[safeRecipientName];
                    groupCount++;

                    const sheetData = [];

                    const headers = getSheetHeaders(selectedFields, hasDateSelected, hasRecipientSelected);
                    sheetData.push(headers);
                    
                    recipientData.forEach(entry => {
                        const rowData = getSheetDataRow(entry, selectedFields, hasDateSelected, hasRecipientSelected);
                        // No es necesario añadir el destinatario de nuevo si ya está en selectedFields
                        sheetData.push(rowData);
                    });

                    const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
                    XLSX.utils.book_append_sheet(workbook, worksheet, safeRecipientName);
                }
            }

            // 3. Escribir el Workbook y descargar
            if (groupCount > 0) {
                try {
                    XLSX.writeFile(workbook, `comprobantes_agrupados_${Date.now()}.xlsx`);
                    infoMessage.textContent = `¡Descarga del libro de Excel (.xlsx) con ${groupCount} hojas (una por destinatario) completada!`;
                    infoMessage.classList.remove('text-red-600', 'font-bold');
                } catch (error) {
                    console.error("Error al generar el archivo XLSX:", error);
                    infoMessage.textContent = "ERROR al generar el archivo XLSX. Ver consola.";
                    infoMessage.classList.add('text-red-600', 'font-bold');
                }
            } else {
                infoMessage.textContent = "ERROR: No hay datos agrupables seleccionados para generar el libro XLSX.";
                infoMessage.classList.add('text-red-600', 'font-bold');
            }
        }


        // --- Manejadores de Eventos ---

        // Toggle del menú de descarga
        toggleDownloadMenuButton.addEventListener('click', () => {
            if (!toggleDownloadMenuButton.disabled) {
                downloadMenu.classList.toggle('hidden');
            }
        });
        
        // Cierra el menú si se hace click fuera
        document.addEventListener('click', (e) => {
            if (!downloadButtonContainer.contains(e.target) && !downloadMenu.classList.contains('hidden')) {
                downloadMenu.classList.add('hidden');
            }
        });

        // Evento para Descarga Agrupada
        downloadGroupedButton.addEventListener('click', () => {
            const data = getSelectedAndValidatedData();
            if (data.length > 0) {
                exportGrouped(data);
                downloadMenu.classList.add('hidden');
            }
        });

        // Evento para Descarga Consolidada
        downloadConsolidatedButton.addEventListener('click', () => {
            const data = getSelectedAndValidatedData();
            if (data.length > 0) {
                exportConsolidated(data);
                downloadMenu.classList.add('hidden');
            }
        });
        
        // Selector/Deselector de todos los CAMPOS
        selectAllFieldsCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            fieldSelectionDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        });

        // Selector/Deselector de todas las FILAS DE RESULTADOS
        selectAllResultsCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            dataList.querySelectorAll('input[type="checkbox"].result-select-item').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            updateDownloadButtonState();
        });
        
        // Seleccionar solo las excepciones de fecha
        selectDateExceptionsButton.addEventListener('click', () => {
            dataList.querySelectorAll('input[type="checkbox"].result-select-item').forEach(checkbox => {
                checkbox.checked = false;
            });

            allExtractedData.forEach((entry, index) => {
                if (entry.isDateException) {
                    const checkbox = document.querySelector(`input[type="checkbox"].result-select-item[data-index="${index}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                }
            });
            updateDownloadButtonState();
        });


        // Listener para los chulos individuales de campos
        fieldSelectionDiv.addEventListener('change', () => {
            const allItems = fieldSelectionDiv.querySelectorAll('input[type="checkbox"]').length;
            const checkedItems = fieldSelectionDiv.querySelectorAll('input[type="checkbox"]:checked').length;
            selectAllFieldsCheckbox.checked = allItems > 0 && checkedItems === allItems;
        });

        // Habilita el botón de proceso y actualiza el contador al seleccionar archivos
        imageUpload.addEventListener('change', () => {
            const fileCount = imageUpload.files.length;
            fileCountSpan.textContent = fileCount;
            // Solo depende de isAuthReady si el proceso de inicialización no ha terminado
            processButton.disabled = fileCount === 0 || !isAuthReady; 
            
            setUIState(false, false, false);
            errorArea.classList.add('hidden');
            allExtractedData = []; 
            infoMessage.textContent = fileCount > 0 ? "Listo para procesar." : "Sistema listo para recibir archivos.";
            infoMessage.classList.remove('text-red-600', 'font-bold');
        });

        // Lógica principal de extracción al hacer clic en el botón
        processButton.addEventListener('click', async () => {
            const files = Array.from(imageUpload.files);
            // El check de !isAuthReady es más importante al inicio del proceso para detenerlo si falla.
            if (files.length === 0 || !isAuthReady) {
                 infoMessage.textContent = "Error: El sistema no está inicializado (Base de datos desconectada) o no hay archivos.";
                 infoMessage.classList.remove('text-gray-500');
                 infoMessage.classList.add('text-red-600', 'font-bold');
                 return;
            }
            
            const selectedFields = getSelectedFields();
            const totalFilesCount = files.length; 

            if (selectedFields.length === 0) {
                infoMessage.textContent = "ERROR: Por favor, selecciona al menos un campo a extraer.";
                infoMessage.classList.remove('text-gray-500');
                infoMessage.classList.add('text-red-600', 'font-bold');
                return;
            } else {
                 infoMessage.classList.remove('text-red-600', 'font-bold');
                 infoMessage.classList.add('text-gray-500');
                 infoMessage.textContent = "Procesando...";
            }

            setUIState(true, false, false); 
            errorArea.classList.add('hidden');
            allExtractedData = []; 
            
            // --- NUEVA LÓGICA DE PRE-PROCESAMIENTO PARA OBTENER HASHES ---
            const filesWithMetadata = [];
            for (const file of files) {
                try {
                    const hash = await calculateFileHash(file);
                    filesWithMetadata.push({
                        file: file,
                        fileName: file.name,
                        hash: hash
                    });
                } catch (e) {
                    console.error(`Error al calcular hash de ${file.name}:`, e);
                    // Si el hash falla, omitimos el archivo, o lo marcamos para no usar caché.
                    filesWithMetadata.push({
                        file: file,
                        fileName: file.name,
                        hash: null // Esto forzará el caché MISS si se llega a intentar usar
                    });
                }
            }
            
            // --- LÓGICA CENTRAL DE EXTRACCIÓN CON CACHÉ (SIN CAMBIOS) ---
            const CONCURRENCY_LIMIT = 5; 
            const { successfulResults, errorOccurred: batchErrorOccurred } = await processInBatches(filesWithMetadata, CONCURRENCY_LIMIT);
            
            allExtractedData = successfulResults;
            const successCount = successfulResults.length;
            let errorOccurred = batchErrorOccurred;

            let duplicationWarning = "";
            let dateLogicResult = { majorityDate: null, nonMajorityCount: 0, majorityCount: 0, totalExtracted: 0 };

            if (successCount > 0) {
                
                const CHECK_FIELD_KEY_DUP = 'receipt_number';
                const isDuplicationCheckPossible = selectedFields.includes(CHECK_FIELD_KEY_DUP);

                if (isDuplicationCheckPossible) {
                    const receiptNumbers = new Set();
                    allExtractedData.forEach(entry => {
                        const receiptNumber = entry.data[CHECK_FIELD_KEY_DUP];
                        if (receiptNumber && receiptNumbers.has(receiptNumber)) {
                            entry.isDuplicate = true;
                        } else if (receiptNumber) {
                            receiptNumbers.add(receiptNumber);
                        }
                    });
                } else {
                    duplicationWarning = " (ADVERTENCIA: No se verificó duplicidad porque el 'Nº Comprobante' no fue seleccionado).";
                }

                if (selectedFields.includes('date')) {
                    dateLogicResult = detectMajorityDateAndExceptions(allExtractedData);
                }
            }

            if (successCount === 0) {
                setUIState(false, true, false); 
            } else {
                displayResults(allExtractedData, duplicationWarning, dateLogicResult);
            }
            setUIState(false, errorOccurred, allExtractedData.length > 0);
        });

    </script>
</body>
</html>

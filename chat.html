<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Moderno</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Asegurar que html y body ocupen toda la altura de la ventanaa */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevenir scroll del body */
            /* Establecer la fuente principal */
            font-family: 'Roboto', sans-serif; /* Usar Roboto, con sans-serif como fallback moderno */
            background-color: #f2f2f7; /* Fondo neutro para PC */
        }

        body {
            display: flex;
            justify-content: center;
            padding: 20px; /* En PC da aire alrededor del chat */
            box-sizing: border-box;
        }

        /* Estilos generales y de contenedor */
        #chat-container {
            width: 100%; /* Ocupar todo el ancho disponible hasta el max-width */
            max-width: 700px; /* Aumentar el ancho m치ximo */
            background-color: #ffffff; /* Fondo blanco limpio */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Sombra m치s suave */
            border-radius: 15px; /* Bordes m치s redondeados */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Altura inicial al 100% del viewport */
            height: calc(100vh - 40px); /* Considera el padding del body en PC */
            max-height: calc(100vh - 40px); /* Asegurar que no exceda el viewport */
            box-sizing: border-box;
            padding: 0; /* Evita desalineaci칩n con el 치rea fija inferior */
        }

        /* Estilos para la secci칩n de ingreso de nombre */
        #name-prompt {
            padding: 30px 20px; /* M치s padding */
            text-align: center;
            background-color: #e5e5ea; /* Gris claro */
            border-bottom: 1px solid #d1d1d6; /* Borde sutil */
            flex-shrink: 0; /* Evitar que se encoja */
        }

        #name-prompt h2 {
            margin-top: 0;
            color: #1c1c1e; /* Texto oscuro */
            font-size: 1.5em; /* Aumentar tama침o del t칤tulo */
        }

        #name-prompt input {
            padding: 12px 15px; /* M치s padding */
            margin-right: 10px;
            border: 1px solid #d1d1d6;
            border-radius: 8px; /* Bordes redondeados */
            font-size: 1.1em; /* Aumentar tama침o de fuente */
            box-sizing: border-box; /* Incluir padding y border */
        }

        #name-prompt button {
            padding: 12px 20px; /* M치s padding */
            background-color: #007aff; /* Azul de Apple */
            color: white;
            border: none;
            border-radius: 8px; /* Bordes redondeados */
            cursor: pointer;
            font-size: 1.1em; /* Aumentar tama침o de fuente */
            transition: background-color 0.2s ease-in-out;
        }

        #name-prompt button:hover {
            background-color: #0056b3; /* Azul m치s oscuro */
        }

        /* Estilos para el encabezado del chat */
        #chat-header {
            display: flex;
            justify-content: space-between; /* Espacio entre t칤tulo/online y bot칩n de settings */
            align-items: center;
            padding: 0 20px 10px 20px; /* Padding superior, sin padding lateral extra */
            flex-shrink: 0;
            position: relative; /* Para posicionar el dropdown */
        }

         #chat-header h2 {
             margin: 0;
             font-size: 1.3em;
             color: #1c1c1e;
         }

        /* Ajustes finos para escritorio (mantener m칩vil intacto) */
        @media (min-width: 769px) {
            #bottom-fixed-area {
                bottom: 20px; /* Alinea visualmente con el padding del body */
            }
        }

         #online-users {
             font-size: 0.9em;
             color: #8e8e93;
             margin-top: 5px;
             min-height: 1.2em; /* Reserva espacio */
         }


        /* Estilos para la caja de chat (mensajes) */
        #chat-box {
            flex-grow: 1; /* Permite que la caja de chat ocupe el espacio restante */
            padding: 0 20px; /* Padding lateral */
            overflow-y: auto; /* Habilita el scroll vertical si los mensajes exceden la altura */
            border-bottom: 1px solid #eee;
            display: flex;
            flex-direction: column;
            gap: 12px; /* M치s espacio entre mensajes */

            /* Estilos para la imagen de fondo */
            background-image: url('https://images.unsplash.com/photo-1518655048521-f130df041722?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* URL de imagen de fondo moderna y sobria */
            background-size: cover; /* Cubrir el 치rea del contenedor */
            background-position: center; /* Centrar la imagen */
            background-repeat: no-repeat; /* No repetir la imagen */
             /* Padding inferior din치mico ajustado por JS */
            padding-bottom: 20px; /* Padding inicial, se ajustar치 con JS */
        }

        /* Estilos para cada mensaje individual */
        .message {
            padding: 12px 18px; /* Aumentar padding del mensaje */
            border-radius: 18px; /* Bordes m치s redondeados */
            max-width: 85%; /* Aumentar ancho m치ximo */
            word-wrap: break-word;
            position: relative;
            line-height: 1.5; /* Mejorar espaciado entre l칤neas */
            font-size: 1.1em; /* Aumentar tama침o de fuente base del mensaje */
            /* A침adir un fondo semi-transparente para que el texto sea legible sobre la imagen */
            background-color: rgba(255, 255, 255, 0.9); /* Blanco con 90% de opacidad */
            cursor: pointer; /* Indicar que se puede hacer clic para responder */
            display: flex; /* Usar flexbox para organizar el contenido interno */
            flex-direction: column; /* Apilar nombre, respuesta, y footer */
            z-index: 1; /* Asegurar que los mensajes est칠n por encima */
        }

        .message .name {
             font-size: 0.9em; /* Tama침o de fuente del nombre (relativo al 1.1em del mensaje) */
             color: #3a3a3c; /* Color de texto sutil */
             margin-bottom: 2px; /* Espacio debajo del nombre */
             display: block;
             font-weight: 600; /* Semi-negrita */
        }

        .message .text {
            display: block;
            font-size: 1em; /* Tama침o de fuente del texto (relativo al 1.1em del mensaje) */
            /* margin-bottom: 4px; Eliminado, el margen ahora est치 en el footer */
             flex-grow: 1; /* Permitir que el texto ocupe espacio */
             min-width: 0; /* Permitir que el texto se encoja y envuelva */
             margin-right: auto; /* Empujar la hora/checks a la derecha */
             padding-right: 8px; /* Espacio entre texto y hora/checks */
             /* Asegurar que el texto se envuelva correctamente */
             overflow-wrap: break-word;
             word-break: break-word;
        }

         /* Estilos para los enlaces dentro de los mensajes */
        .message a {
            color: #007aff; /* Color azul para enlaces */
            text-decoration: none; /* Sin subrayado por defecto */
        }

        .message a:hover {
            text-decoration: underline; /* Subrayado al pasar el rat칩n */
        }


         /* Contenedor para texto, hora y checkmarks */
         .message-footer {
             display: flex;
             align-items: center; /* Alinear verticalmente */
             justify-content: flex-end; /* Alinear a la derecha */
             flex-wrap: wrap; /* Permitir que los elementos se envuelvan si no hay espacio */
             /* gap: 5px; */ /* Espacio entre elementos del footer */
             margin-top: 4px; /* Espacio arriba del footer */
         }


        .message .timestamp {
            font-size: 0.7em; /* Tama침o de fuente de la hora (relativo al 1.1em del mensaje) */
            color: #8e8e93; /* Gris tenue */
            /* text-align: right; Eliminado, manejado por flexbox */
            display: inline-block; /* O inline, ambos funcionan con flexbox */
             /* margin-top: 4px; Eliminado, el margen est치 en el footer */
             flex-shrink: 0; /* Evitar que se encoja */
             margin-left: 4px; /* Espacio a la izquierda del timestamp */
        }

         /* Estilos para los checkmarks */
         .message .checkmarks {
             font-size: 0.8em; /* Tama침o de los checkmarks */
             color: #007aff; /* Color azul para checkmarks */
             margin-left: 4px; /* Espacio a la izquierda */
             vertical-align: middle; /* Alinear verticalmente */
             display: inline; /* O inline-block */
             flex-shrink: 0; /* Evitar que se encoja */
         }


        /* Estilos para mensajes recibidos */
        .message.received {
            background-color: rgba(229, 229, 234, 0.9); /* Gris claro con 90% de opacidad */
            align-self: flex-start;
            border-bottom-left-radius: 5px; /* Esquina inferior izquierda menos redondeada */
        }

        /* Estilos para mensajes enviados */
        .message.sent {
            background-color: rgba(0, 122, 255, 0.9); /* Azul con 90% de opacidad */
            color: white; /* Texto blanco */
            align-self: flex-end;
            border-bottom-right-radius: 5px; /* Esquina inferior derecha menos redondeada */
        }

         /* Estilos para mensajes enviados - elementos internos */
        .message.sent .name,
        .message.sent .text,
        .message.sent .timestamp {
            /* color: white !important; Removido para probar inline style */
            color: inherit;
        }
         .message.sent .timestamp {
             /* color: rgba(255, 255, 255, 0.8) !important; Removido para probar inline style */
             color: inherit;
         }
         .message.sent .checkmarks {
             color: white !important; /* Checkmarks blancos en mensajes enviados, forzar */
         }

        /* Estilos para el contenedor del video de YouTube y otros embeds */
        .video-preview-container {
            margin-top: 8px; /* Espacio entre el texto y el video */
            margin-bottom: 4px; /* Espacio entre el video y el footer */
            width: 100%; /* Ocupar el ancho del mensaje */
            aspect-ratio: 16 / 9; /* Mantener relaci칩n de aspecto 16:9 */
            overflow: hidden; /* Asegurar que el iframe o video no se salga */
            border-radius: 8px; /* Bordes redondeados para la previsualizaci칩n */
        }

        .video-preview-container iframe,
        .video-preview-container video {
            width: 100%;
            height: 100%;
            border: none; /* Eliminar borde */
        }


        /* Contenedor fijo para el 치rea de input y el indicador de escribiendo */
        #bottom-fixed-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%; /* Ocupar todo el ancho */
            max-width: 700px; /* Igual que el contenedor principal */
            box-sizing: border-box; /* Incluir padding en el ancho */
            margin: 0 auto; /* Centrar horizontalmente */
            z-index: 5; /* Asegurar que est칠 por encima de la caja de chat */
            display: flex; /* Usar flexbox */
            flex-direction: column; /* Apilar elementos verticalmente */
             /* background-color: #f9f9f9; Eliminado el color de fondo */
             border-top: 1px solid #eee; /* Borde superior */
             padding: 10px 20px; /* Padding interno */
        }

        /* --- Debugging Styles for typing indicator --- */
        #typing-indicator {
            font-size: 0.9em; /* Aumentar tama침o */
            color: #8e8e93; /* Gris tenue */
            padding: 0 5px; /* Padding interno */
            min-height: 1.2em; /* Reserva espacio */
            text-align: right; /* Alinear a la derecha */
            margin-bottom: 5px; /* A침adir margen debajo del indicador */
            /* border: 1px dashed blue; Debugging border */
            /* background-color: rgba(0, 0, 255, 0.1); Debugging background */
        }
        /* --- End Debugging Styles --- */


        /* Estilos para el 치rea de entrada de mensajes (ahora dentro del contenedor fijo) */
        .message-input-area {
            display: flex;
            /* flex-direction: column; Eliminado, el contenedor padre ya es flex-direction: column */
            /* padding: 15px 20px; Eliminado, el padding est치 en el contenedor fijo */
            /* background-color: #f9f9f9; Eliminado, el fondo est치 en el contenedor fijo */
            /* border-top: 1px solid #eee; Eliminado, el borde est치 en el contenedor fijo */
            align-items: center; /* Centrar horizontalmente */
            gap: 10px; /* Espacio entre elementos */
            flex-shrink: 0; /* Evita que el 치rea de entrada se encoja */
            /* Propiedades de position: fixed restauradas */
            /* Eliminado: position, bottom, left, right, width, max-width, box-sizing, margin, z-index */
        }


        /* Contenedor para el input y los botones */
        .input-container {
            display: flex; /* Alinear elementos horizontalmente */
            align-items: flex-end; /* Alinear verticalmente los elementos al final (bottom) */
            gap: 10px; /* Espacio entre input y botones */
            width: 100%; /* Ocupar todo el ancho disponible */
        }


        /* Estilos para el TEXTAREA */
        .message-input-area textarea {
            flex-grow: 1; /* Permite que el textarea ocupe el espacio restante */
            /* Ajuste de padding para hacerlo menos "gordo" */
            padding: 8px 15px;
            border: 1px solid #d1d1d6;
            border-radius: 20px; /* Bordes muy redondeados */
            font-size: 1.1em;
            box-sizing: border-box;
            outline: none; /* Eliminar contorno al enfocar */
            transition: border-color 0.2s ease-in-out;
            line-height: 1.5; /* Igual que los mensajes para consistencia */
            resize: none; /* Deshabilitar el redimensionamiento manual por el usuario */
            min-height: 40px; /* Altura m칤nima similar a la del input original */
            max-height: 120px; /* Altura m치xima para evitar que crezca demasiado */
            overflow-y: auto; /* Mostrar scrollbar si el contenido excede max-height */
        }
         .message-input-area textarea:focus {
             border-color: #007aff; /* Borde azul al enfocar */
         }


         .message-input-area .input-buttons {
             display: flex; /* Alinear botones horizontalmente */
             gap: 5px; /* Espacio entre los botones */
             align-items: center; /* Centrar verticalmente los botones */
             flex-shrink: 0; /* Evitar que los botones se encoja */
         }

         /* Estilo base para los botones de icono */
        .message-input-area button {
            padding: 10px; /* Padding uniforme para botones de icono */
            background-color: #e5e5ea; /* Fondo gris claro para botones de icono */
            color: #007aff; /* Color azul para iconos */
            border: none;
            border-radius: 50%; /* Botones redondos */
            cursor: pointer;
            /* Ajuste de tama침o fijo para botones redondos */
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
        }

         /* Estilo espec칤fico para el bot칩n de enviar */
         #send-button {
             background-color: #007aff; /* Fondo azul para enviar */
             color: white; /* Texto blanco */
             border-radius: 20px; /* Bordes redondeados */
             padding: 10px 20px; /* Padding horizontal */
             width: auto; /* Ancho autom치tico */
             height: auto; /* Altura autom치tica */
         }

         #send-button:hover {
             background-color: #0056b3;
         }

         /* Estilo espec칤fico para el bot칩n de emoji */
         #emoji-button {
             /* Ya tienen estilos base de .message-input-area button */
             -webkit-tap-highlight-color: transparent;
         }

         #emoji-button svg {
             width: 22px; /* Tama침o del icono SVG */
             height: 22px; /* Tama침o del icono SVG */
             fill: #3a3a3c; /* Color del icono oscuro */
         }
          #emoji-button:hover {
              background-color: #d1d1d6; /* Gris un poco m치s oscuro al pasar el rat칩n */
          }

        /* Estilos para el bot칩n de limpiar chat */
        /* Ahora dentro del dropdown */
        #settings-dropdown button { /* Aplicar a todos los botones dentro del dropdown */
            padding: 10px 15px; /* Padding para elemento de men칰 */
            background-color: transparent; /* Fondo transparente */
            color: #1c1c1e; /* Color de texto oscuro */
            border: none;
            border-radius: 0; /* Sin bordes redondeados */
            cursor: pointer;
            font-size: 1em; /* Tama침o de fuente est치ndar */
            margin: 0; /* Sin margen */
            width: 100%; /* Ocupar todo el ancho del dropdown */
            text-align: left; /* Alinear texto a la izquierda */
            transition: background-color 0.1s ease-in-out;
            display: block; /* Asegurar que sea un bloque para ocupar el ancho */
        }

        #settings-dropdown button:hover { /* Aplicar a todos los botones al pasar el rat칩n */
            background-color: #e5e5ea; /* Fondo gris claro al pasar el rat칩n */
        }

        /* Estilo espec칤fico para el bot칩n de limpiar chat al pasar el rat칩n */
        #settings-dropdown #clear-chat-button:hover {
             color: #ff3b30; /* Color rojo al pasar el rat칩n */
        }


        /* Oculta la interfaz de chat inicialmente */
        #chat-interface {
            display: none;
            flex-direction: column;
            flex-grow: 1; /* Asegura que la interfaz de chat ocupe el espacio disponible */
             /* Ajuste clave: Darle una altura al contenedor flex para que los hijos flex-grow funcionen */
            height: 100%;
            position: relative; /* Necesario para posicionar el selector de emojis si se pone fuera del input-area */
        }

        /* Estilos para el selector de emojis */
        #emoji-picker {
            display: none; /* Oculto por defecto */
            position: absolute;
            /* bottom se ajusta din치micamente en JS */
            left: 20px; /* Alinear a la izquierda */
            background-color: #fff;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Asegurar que est칠 por encima de otros elementos */
            max-height: 200px; /* Altura m치xima para scroll */
            overflow-y: auto; /* Habilitar scroll si hay muchos emojis */
            width: calc(100% - 40px); /* Ocupar el ancho del contenedor con padding */
            box-sizing: border-box;
            flex-wrap: wrap; /* Permite que los emojis se envuelvan */
            gap: 5px; /* Espacio entre emojis */
        }

        #emoji-picker span {
            cursor: pointer;
            font-size: 1.5em; /* Tama침o de los emojis */
            padding: 3px;
            border-radius: 4px;
            transition: background-color 0.1s ease-in-out;
        }

        #emoji-picker span:hover {
            background-color: #e5e5ea;
        }

        /* Estilos para la vista previa del mensaje al responder */
        #reply-preview {
            display: none; /* Oculto por defecto */
            background-color: #e5e5ea; /* Fondo gris claro */
            border-left: 4px solid #007aff; /* Barra azul a la izquierda */
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px; /* Espacio debajo de la vista previa */
            width: 100%; /* Ocupar todo el ancho */
            box-sizing: border-box;
            position: relative; /* Para posicionar el bot칩n de cerrar */
        }

        #reply-preview .reply-name {
            font-size: 0.9em;
            color: #3a3a3c;
            font-weight: 600;
            margin-bottom: 2px;
            display: block;
        }

        #reply-preview .reply-text {
            font-size: 1em;
            color: #1c1c1e;
            display: block;
            /* Limitar el texto para que no sea demasiado largo */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #reply-preview #cancel-reply-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #8e8e93; /* Color gris */
            font-size: 1.2em;
        }

        #reply-preview #cancel-reply-button:hover {
            color: #3a3a3c; /* Gris m치s oscuro al pasar el rat칩n */
        }

        /* Estilos para mostrar el contenido de la respuesta dentro de un mensaje */
        .message .reply-content {
            background-color: rgba(0, 0, 0, 0.05); /* Fondo ligeramente oscuro */
            border-left: 4px solid rgba(0, 122, 255, 0.5); /* Barra azul semi-transparente */
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px; /* Espacio debajo del contenido de respuesta */
            font-size: 0.9em; /* Tama침o de fuente m치s peque침o */
            word-wrap: break-word;
        }

        .message.sent .reply-content {
             border-left-color: rgba(255, 255, 255, 0.5); /* Barra blanca semi-transparente en mensajes enviados */
        }


        .message .reply-content .reply-name {
            font-weight: 600;
            margin-bottom: 2px;
            display: block;
            color: #3a3a3c; /* Color de texto sutil */
        }
         .message.sent .reply-content .reply-name {
             color: rgba(255, 255, 255, 0.8); /* Color de texto sutil en mensajes enviados */
         }


        .message .reply-content .reply-text {
            display: block;
            color: #1c1c1e; /* Texto oscuro */
            /* Limitar el texto para que no sea demasiado largo */
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
        }
         .message.sent .reply-content .reply-text {
             color: white; /* Texto blanco en mensajes enviados */
         }


        /* Estilos para el men칰 desplegable de configuraci칩n */
        #settings-dropdown {
            display: none; /* Oculto por defecto */
            position: absolute;
            /* bottom y right se ajustan din치micamente en JS o se calculan */
            background-color: #fff;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Asegurar que est칠 por encima de otros elementos */
            min-width: 150px; /* Ancho m칤nimo del men칰 */
            padding: 5px 0; /* Padding interno */
            flex-direction: column; /* Elementos apilados verticalmente */
            top: 40px; /* Posicionar debajo del bot칩n de settings */
            right: 20px; /* Alinear a la derecha del chat-header */
        }


        /* Media query para pantallas m치s peque침as (Android) */
        @media (max-width: 768px) {
            body {
                padding: 0; /* Eliminar padding del body en m칩viles */
                display: block;
            }
            #chat-container {
                max-width: 100vw; /* Ocupar todo el ancho del viewport */
                border-radius: 0; /* Eliminar bordes redondeados en pantalla completa */
                 padding: 0; /* Eliminar padding del contenedor en m칩viles */
                 height: 100vh;
                 max-height: 100vh;
            }

            #name-prompt {
                padding: 20px 15px;
            }

            #name-prompt input,
            #name-prompt button {
                font-size: 1em; /* Ajustar tama침o de fuente */
                padding: 10px 12px; /* Ajustar padding */
            }

             #name-prompt input[type="text"] { /* Especificar input de texto */
                 margin-right: 5px;
                 align-self: center; /* Centrar verticalmente */
             }

             /* Contenedor fijo para el 치rea de input y el indicador de escribiendo en m칩viles */
             #bottom-fixed-area {
                 max-width: 100vw;
                 padding: 10px 15px; /* Ajustar padding para m칩viles */
                 bottom: 0;
             }


             .message-input-area {
                 display: flex;
                 gap: 5px;
                 align-items: center; /* Centrar horizontalmente */
                 flex-shrink: 0; /* Evita que el 치rea de entrada se encoja */
             }

             .message-input-area .input-buttons {
                 gap: 5px;
                 align-items: center; /* Centrar verticalmente */
                 flex-shrink: 0; /* Asegurar que no se encoja */
             }

             /* Ajuste para textarea en m칩viles */
             .message-input-area textarea {
                 font-size: 1em;
                 padding: 8px 12px; /* Ajustar padding */
                 min-height: 40px; /* Asegurar altura m칤nima */
                 max-height: 100px; /* Ajustar altura m치xima para m칩viles */
                 flex-grow: 1;
                 box-sizing: border-box;
             }

             .input-container {
                 flex-direction: row; /* Alinear horizontalmente en m칩viles */
                 align-items: flex-end; /* Alinear verticalmente los elementos al final (bottom) */
                 gap: 5px;
             }


             #emoji-button, #send-button {
                 width: 40px;
                 height: 40px;
                 padding: 0; /* Eliminar padding extra */
                 flex-shrink: 0; /* Evitar que se reduzcan */
                 align-self: center; /* Centrar verticalmente */
             }
              #send-button {
                  width: auto; /* Permitir que el bot칩n de enviar ajuste su ancho */
                  padding: 10px 15px;
              }


              #emoji-button svg, #settings-button svg {
                 width: 20px;
                 height: 20px;
             }

             #settings-button {
                 /* Ajuste de tama침o y posici칩n para m칩viles */
                 width: 40px;
                 height: 40px;
                 padding: 0;
                 align-self: center;
                 font-size: 1.5em; /* Tama침o para el emoji */
                 /* A침adido para intentar centrar el emoji */
                 line-height: 1;
                 vertical-align: middle;
             }

             #settings-dropdown button { /* Aplicar a todos los botones dentro del dropdown */
                 font-size: 0.9em;
                 padding: 8px 12px;
             }

             .message {
                 max-width: 90%; /* Permitir que los mensajes ocupen m치s ancho */
             }

             /* Ajuste del indicador de escribiendo en m칩viles */
             #typing-indicator {
                 /* align-self: flex-end; Eliminado */
                 /* margin-bottom: 5px; Eliminado */
                 padding: 0 5px; /* Ajustar padding lateral para m칩viles */
                 text-align: right; /* Asegurar alineaci칩n derecha */
                 margin-bottom: 5px; /* A침adir margen debajo del indicador */
             }

             /* Ajuste del selector de emojis en m칩viles */
             #emoji-picker {
                 /* bottom se ajustar치 din치micamente en JS */
                 left: 10px;
                 width: calc(100% - 20px); /* Ajustar ancho para m칩viles */
             }

             /* Ajuste de la vista previa de respuesta en m칩viles */
             #reply-preview {
                 padding: 8px 10px;
             }

             /* Ajuste del dropdown de settings en m칩viles */
             #settings-dropdown {
                 top: 40px; /* Posicionar debajo del bot칩n de settings */
                 right: 10px; /* Alinear a la derecha en m칩viles */
                 left: auto; /* Desactivar alineaci칩n izquierda */
             }
        }

         /* Estilos para el bot칩n de configuraci칩n en general */
         #settings-button {
             /* Ajuste de tama침o y posici칩n */
             width: 40px;
             height: 40px;
             padding: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             background-color: transparent; /* Fondo transparente */
             border: none;
             border-radius: 50%; /* Bot칩n redondo */
             cursor: pointer;
             font-size: 1.5em; /* Tama침o para el emoji */
             color: #1c1c1e; /* Color oscuro para el emoji */
             /* A침adido para intentar centrar el emoji */
             line-height: 1;
             vertical-align: middle;
         }

         #settings-button:hover {
             background-color: #e5e5ea; /* Fondo gris claro al pasar el rat칩n */
         }


        /* Lock Overlay */
        #lock-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 500;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #lock-overlay.active { display: flex; }
        .lock-content { text-align: center; padding: 40px; }
        .lock-icon { font-size: 64px; margin-bottom: 16px; }
        .lock-content h2 { font-size: 1.6em; color: #1c1c1e; margin-bottom: 8px; }
        .lock-content p { font-size: 1em; color: #8e8e93; margin-bottom: 28px; }
        .lock-buttons { display: flex; gap: 12px; justify-content: center; }
        .lock-btn { padding: 12px 24px; border: none; border-radius: 10px; font-size: 1em; font-weight: 600; cursor: pointer; transition: background-color .2s; }
        .lock-btn.primary { background-color: #007aff; color: #fff; }
        .lock-btn.primary:hover { background-color: #0056b3; }
        .lock-btn.secondary { background-color: #e5e5ea; color: #1c1c1e; }
        .lock-btn.secondary:hover { background-color: #d1d1d6; }

        /* Password / Prompt Modal */
        #password-modal, #prompt-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.4);
            z-index: 600;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        #password-modal.active, #prompt-modal.active { display: flex; }
        .pw-modal-card {
            background: #fff;
            border-radius: 14px;
            padding: 28px 32px;
            width: 90%;
            max-width: 340px;
            box-shadow: 0 8px 30px rgba(0,0,0,.15);
            text-align: center;
        }
        .pw-modal-card h3 { font-size: 1.2em; color: #1c1c1e; margin-bottom: 16px; }
        .pw-modal-card input {
            width: 100%; padding: 10px 14px; border: 1px solid #d1d1d6; border-radius: 8px;
            font-size: 1em; box-sizing: border-box; outline: none; margin-bottom: 8px;
        }
        .pw-modal-card input:focus { border-color: #007aff; box-shadow: 0 0 0 3px rgba(0,122,255,.12); }
        #pw-modal-error { font-size: .85em; color: #ff3b30; min-height: 1.2em; margin-bottom: 12px; }
        .pw-modal-actions { display: flex; gap: 10px; justify-content: center; }

    </style>

    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-analytics-compat.js"></script>

</head>
<body>

    <div id="chat-container">
        <div id="name-prompt">
            <h2>Ingresa tu nombre</h2>
            <input type="text" id="name-input" placeholder="Tu nombre">
            <button id="start-chat-button">Entrar al Chat</button>
        </div>

        <div id="chat-interface">
            <div id="chat-header">
                 <div>
                     <h2>FACBA</h2>
                     <div id="online-users"></div> </div>
                 <button id="settings-button" title="Configuraci칩n">
                      丘뙖잺
                 </button>
                 <div id="settings-dropdown">
                     <button id="lock-chat-button">游 Bloqueo</button>
                     <button id="clear-chat-button">Limpiar Chat</button>
                     <button id="change-name-button">Cambiar Nombre</button>
                 </div>
            </div>
             <div id="chat-box">
                </div>
            <div id="bottom-fixed-area">
                <div id="typing-indicator"></div>
                 <div id="emoji-picker">
                     </div>
                 <div id="reply-preview">
                     <span class="reply-name"></span>
                     <span class="reply-text"></span>
                     <button id="cancel-reply-button">칑</button>
                 </div>
                <div class="message-input-area">
                    <textarea id="message-input" placeholder="Escribe un mensaje..." autocomplete="off" autocorrect="off" rows="1"></textarea>
                    <div class="input-buttons">
                         <button id="emoji-button" title="Insertar Emoji">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm0 22c-5.514 0-10-4.486-10-10s4.486-10 10-10 10 4.486 10 10-4.486 10-10 10zm-3-8c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm6 0c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm-3 4c-2.04 0-3.831-1.242-4.588-3h9.176c-.757 1.758-2.548 3-4.588 3z"/>
                            </svg>
                        </button>
                         <button id="send-button">Enviar</button>
                    </div>
                 </div>
            </div>
             </div>
    </div>

    <!-- Lock Overlay -->
    <div id="lock-overlay">
        <div class="lock-content">
            <div class="lock-icon">游</div>
            <h2>No disponible</h2>
            <p>Esta p치gina se encuentra bloqueada</p>
            <div class="lock-buttons">
                <button id="lock-help-btn" class="lock-btn primary">Ayuda</button>
                <button id="lock-more-btn" class="lock-btn secondary">M치s opciones</button>
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="password-modal">
        <div class="pw-modal-card">
            <h3 id="pw-modal-title">Ingresa la clave</h3>
            <input type="password" id="pw-modal-input" placeholder="Contrase침a" autocomplete="off"/>
            <p id="pw-modal-error"></p>
            <div class="pw-modal-actions">
                <button id="pw-modal-cancel" class="lock-btn secondary">Cancelar</button>
                <button id="pw-modal-ok" class="lock-btn primary">Aceptar</button>
            </div>
        </div>
    </div>

    <!-- Prompt Modal (replaces browser prompt) -->
    <div id="prompt-modal">
        <div class="pw-modal-card">
            <h3 id="prompt-modal-title">Ingresa un valor</h3>
            <input type="text" id="prompt-modal-input" placeholder="" autocomplete="off"/>
            <div class="pw-modal-actions">
                <button id="prompt-modal-cancel" class="lock-btn secondary">Cancelar</button>
                <button id="prompt-modal-ok" class="lock-btn primary">Aceptar</button>
            </div>
        </div>
    </div>

    <audio id="notification-sound" src="sonido_mensaje.mp3" preload="auto"></audio>


    <script>
        // Configuraci칩n de tu aplicaci칩n web de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyBVtSkeQe1WZna6nKC4vxd4ISRBRB5SVY", // Reemplaza con tu apiKey
            authDomain: "facba-a160c.firebaseapp.com", // Reemplaza con tu authDomain
            projectId: "facba-a160c", // Reemplaza con tu projectId
            storageBucket: "facba-a160c.firebasestorage.app", // Reemplaza con tu storageBucket (aunque no se use Storage)
            messagingSenderId: "585530132394", // Reemplaza con tu messagingSenderId
            appId: "1:585530132394:web:a25cda63f883f786804dd3", // Reemplaza con tu appId
            measurementId: "G-S29LSYM8TQ", // Reemplaza con tu measurementId
            // A침adir expl칤citamente la URL de la base de datos
            databaseURL: "https://facba-a160c-default-rtdb.firebaseio.com/" // Reemplaza con tu databaseURL
        };

        // Inicializar Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database(); // Obtener la instancia de Realtime Database

        let userName = ''; // Variable para almacenar el nombre del usuario
        let typingTimeout; // Para manejar el indicador de escribiendo
        let initialLoadComplete = false; // Bandera para saber si la carga inicial de mensajes ha terminado
        let audioUnlocked = false; // Bandera para rastrear si el audio se ha desbloqueado


        // Variable para almacenar los datos del mensaje al que se est치 respondiendo
        let replyingToMessage = null;

        // Intersection Observer para detectar cuando los mensajes son visibles
        let messageObserver;


        // Obtener elementos del DOM
        const namePrompt = document.getElementById('name-prompt');
        const nameInput = document.getElementById('name-input');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInterface = document.getElementById('chat-interface');
        const chatBox = document.getElementById('chat-box');
        // Cambiado de input type="text" a textarea
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator'); // Elemento para el indicador
        const notificationSound = document.getElementById('notification-sound'); // Elemento de audio
        const emojiButton = document.getElementById('emoji-button'); // Bot칩n de emoji
        const emojiPicker = document.getElementById('emoji-picker'); // Selector de emojis
        const replyPreview = document.getElementById('reply-preview'); // Vista previa de respuesta
        const replyNameSpan = replyPreview.querySelector('.reply-name');
        const replyTextSpan = replyPreview.querySelector('.reply-text');
        const cancelReplyButton = document.getElementById('cancel-reply-button');
        // Nuevos elementos para configuraci칩n
        const settingsButton = document.getElementById('settings-button'); // Ahora en chat-header
        const settingsDropdown = document.getElementById('settings-dropdown'); // Ahora en chat-header
        const clearChatButton = document.getElementById('clear-chat-button'); // Ahora dentro del dropdown
        const changeNameButton = document.getElementById('change-name-button'); // Nuevo bot칩n para cambiar nombre
        const chatContainer = document.getElementById('chat-container'); // Referencia al contenedor principal
        const messageInputArea = document.querySelector('.message-input-area'); // Referencia al 치rea de input
        const onlineUsersDiv = document.getElementById('online-users'); // Elemento para usuarios en l칤nea
        const bottomFixedArea = document.getElementById('bottom-fixed-area'); // Nuevo contenedor fijo


        // --- L칩gica de Ingreso de Nombre ---
        startChatButton.addEventListener('click', () => {
            const enteredName = nameInput.value.trim(); // Obtener el nombre y eliminar espacios en blanco
            if (enteredName) {
                userName = enteredName;
                namePrompt.style.display = 'none'; // Ocultar la secci칩n de nombre
                chatInterface.style.display = 'flex'; // Mostrar la interfaz de chat
                messageInput.focus(); // Poner el foco en el campo de mensaje
                // Opcional: Guardar el nombre en localStorage para recordarlo
                localStorage.setItem('chatName', userName);
                initializeChat(); // Inicializar la carga de mensajes y listeners
            } else {
                // Usar un mensaje en el DOM en lugar de alert()
                // Podr칤as a침adir un elemento div para mostrar errores
                 console.log('Por favor, ingresa un nombre.'); // Usar console.log como alternativa simple
            }
        });

        // Permitir presionar Enter en el campo de nombre
        nameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                startChatButton.click(); // Simular clic en el bot칩n
            }
        });

        // --- Funci칩n para inicializar la carga y los listeners del chat ---
        function initializeChat() {
             console.log("initializeChat function called.");
             setupMessageObserver(); // Configurar el Intersection Observer
             loadInitialMessages(); // Cargar mensajes existentes una vez
             setupRealtimeListeners(); // Configurar listeners en tiempo real una vez
             setupTypingIndicator(); // Configurar el indicador de escribiendo
             setupPresence(); // Configurar la presencia del usuario
             setupChatLockListener(); // Escuchar estado de bloqueo global
             // El desbloqueo de audio ahora se maneja en la primera interacci칩n del usuario (enviar mensaje)
        }


        // --- L칩gica del Chat (Realtime Database) ---

        // Referencia al nodo 'messages' en la base de datos
        const messagesRef = database.ref('messages'); // 'messages' es el nombre del nodo
        // Referencia al nodo para el estado de escritura
        const typingRef = database.ref('typing');
        // Referencia al nodo para la presencia de usuarios
        const presenceRef = database.ref('presence');
        // Referencia al nodo para el bloqueo global del chat
        const chatLockRef = database.ref('chat_lock');


        // Clave para limpiar el chat (춰Mant칠n esto seguro en una aplicaci칩n real!)
        const CLEAR_CHAT_PASSWORD = '9999';


        // Funci칩n para formatear el timestamp a HH:MM
        function formatTimestamp(timestamp) {
            if (!timestamp) return ''; // Manejar caso sin timestamp
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // Funci칩n para enviar un mensaje (texto o respuesta)
        function sendMessage() {
            console.log("sendMessage function called."); // Debugging log
            const messageText = messageInput.value.trim(); // Obtener el texto del mensaje y limpiar
            console.log("Message text:", messageText); // Debugging log
            console.log("User name:", userName); // Debugging log

            if (messageText && userName) { // Asegurarse de que haya texto y nombre de usuario
                const newMessage = {
                    name: userName,
                    text: messageText,
                    timestamp: firebase.database.ServerValue.TIMESTAMP, // Usar el timestamp del servidor de Firebase
                    status: 'sent' // Estado inicial: enviado
                };

                // Si estamos respondiendo a un mensaje, a침adir la referencia
                if (replyingToMessage) {
                    newMessage.replyTo = {
                        id: replyingToMessage.id, // ID 칰nico del mensaje original
                        name: replyingToMessage.name,
                        content: replyingToMessage.text ? replyingToMessage.text.substring(0, 50) + (replyingToMessage.text.length > 50 ? '...' : '') : 'Archivo' // Fragmento del texto o indicar que es archivo
                    };
                    console.log("Sending as a reply to:", replyingToMessage.id); // Debugging log
                }

                console.log("Attempting to send message to Realtime Database:", newMessage); // Debugging log

                // Enviar el nuevo mensaje a la base de datos
                messagesRef.push(newMessage)
                    .then(() => {
                        console.log("Mensaje enviado exitosamente a Realtime Database!");
                        messageInput.value = ''; // Limpiar el campo de entrada
                        setTypingStatus(false); // Limpiar estado de escritura
                        cancelReply(); // Cancelar el estado de respuesta despu칠s de enviar
                        // Despu칠s de enviar, ajustar la altura del textarea a la m칤nima
                        messageInput.style.height = 'auto';
                    })
                    .catch((error) => {
                        console.error("Error al enviar mensaje a Realtime Database:", error);
                        // Mostrar mensaje de error al usuario
                    });
            } else {
                 console.log("Message not sent: text or user name missing."); // Debugging log
            }
        }

        // Listener para el bot칩n de enviar texto
        sendButton.addEventListener('click', sendMessage);

        // Permitir presionar Enter en el campo de mensaje de texto (solo si no hay Shift)
        messageInput.addEventListener('keypress', (event) => {
            // Si es Enter y no Shift+Enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevenir el salto de l칤nea por defecto
                sendMessage(); // Enviar el mensaje
            }
            // Si es Shift+Enter, permitir el salto de l칤nea
        });


         // --- L칩gica de Ajuste de Altura del Textarea ---

        // Funci칩n para ajustar la altura del textarea autom치ticamente
        function adjustTextareaHeight() {
             // Restablecer la altura a 'auto' para que se recalcule correctamente
            messageInput.style.height = 'auto';
            // Establecer la altura al scrollHeight (altura necesaria para mostrar todo el contenido)
            // Limitar por max-height definido en CSS
            messageInput.style.height = messageInput.scrollHeight + 'px';
            // Despu칠s de ajustar la altura del textarea, ajustar el padding inferior del chatBox
            adjustChatBoxPadding();
        }

        // Listener para el evento 'input' en el textarea para ajustar la altura
        messageInput.addEventListener('input', adjustTextareaHeight);


         // --- L칩gica del Indicador de Escribiendo (Realtime Database) ---

        // Funci칩n para establecer el estado de escritura en Realtime Database
        function setTypingStatus(isTyping) {
            if (!userName) return; // No hacer nada si el nombre del usuario no est치 establecido

            const userTypingRef = typingRef.child(userName); // Referencia al estado del usuario actual en RTDB

            if (isTyping) {
                userTypingRef.set(true); // Establecer el estado a true
                // Limpiar el estado despu칠s de un tiempo si el usuario deja de escribir
                if (typingTimeout) clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    userTypingRef.remove(); // Eliminar el estado despu칠s de 1.5 segundos
                }, 1500);
            } else {
                 // Limpiar el timeout si existe
                 if (typingTimeout) {
                     clearTimeout(typingTimeout);
                     typingTimeout = null;
                 }
                 userTypingRef.remove(); // Eliminar el estado si ya no est치 escribiendo
            }
        }

        // Listener para el campo de entrada de mensaje para detectar escritura
        messageInput.addEventListener('input', () => {
            if (messageInput.value.trim().length > 0) {
                setTypingStatus(true); // El usuario est치 escribiendo
            } else {
                setTypingStatus(false); // El usuario ha borrado el texto
            }
        });

        // Configurar el listener para el estado de escritura de otros usuarios
        function setupTypingIndicator() {
            typingRef.on('value', (snapshot) => { // Listener en RTDB
                const typingUsers = snapshot.val();
                const usersTyping = [];

                if (typingUsers) {
                    // Iterar sobre los usuarios que est치n escribiendo
                    for (const name in typingUsers) {
                        // Asegurarse de que no sea el usuario actual
                        if (name !== userName) {
                            usersTyping.push(name);
                        }
                    }
                }

                // Actualizar el texto del indicador
                if (usersTyping.length > 0) {
                    typingIndicator.textContent = `${usersTyping.join(', ')} est치 escribiendo...`;
                } else {
                    typingIndicator.textContent = ''; // Limpiar si nadie est치 escribiendo
                }
                // Despu칠s de actualizar el indicador, ajustar el padding del chatBox
                adjustChatBoxPadding();
            });
        }


        // --- L칩gica para Cargar Mensajes Iniciales (Realtime Database) ---
        function loadInitialMessages() {
             console.log("loadInitialMessages function called."); // Debugging log

             // Cargar mensajes existentes una vez al inicio
             messagesRef.once('value', (snapshot) => {
                 console.log("Initial message load from Realtime Database complete.");
                 const messages = snapshot.val();
                 if (messages) {
                     // Convertir objeto de mensajes a array y ordenar por timestamp
                     const messageList = Object.keys(messages).map(key => ({ id: key, ...messages[key] }));
                     messageList.sort((a, b) => a.timestamp - b.timestamp);

                     // Limpiar el chatbox antes de cargar los mensajes existentes
                     chatBox.innerHTML = '';

                     messageList.forEach((msg) => {
                         displayMessage(msg, msg.id); // Pasar el ID a displayMessage
                     });
                 }
                 chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 initialLoadComplete = true; // Marcar la carga inicial como completa
             }, (error) => {
                 console.error("Error fetching initial messages from Realtime Database:", error);
             });
        }

        // --- L칩gica para Configurar Listeners en Tiempo Real (Realtime Database) ---
        function setupRealtimeListeners() {
            console.log("setupRealtimeListeners function called.");

             // Escuchar en tiempo real los mensajes nuevos desde Realtime Database
             // Este listener solo se adjunta UNA VEZ
             messagesRef.on('child_added', (data) => {
                 const newMessage = data.val();
                 const messageId = data.key; // Obtener el ID 칰nico del mensaje
                 console.log(`[${userName}] child_added event:`, newMessage, "ID:", messageId); // Debugging log con nombre de usuario

                 // Solo mostrar el mensaje si no es parte de la carga inicial
                 // La bandera initialLoadComplete ayuda a diferenciar
                 if (initialLoadComplete) {
                    displayMessage(newMessage, messageId); // Mostrar el nuevo mensaje
                    // Reproducir sonido si el mensaje no es del usuario actual
                     if (newMessage.name !== userName) {
                         playNotificationSound();
                     }
                    chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 } else {
                     // Si a칰n no ha terminado la carga inicial, no hacemos nada con este evento
                     // porque ya se mostrar치 en loadInitialMessages
                     console.log(`[${userName}] Ignoring child_added event during initial load.`); // Debugging log con nombre de usuario
                 }

             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for messages (child_added):`, error); // Debugging log con nombre de usuario
             });

             // Listener para actualizar el estado de los mensajes (para doble check)
             messagesRef.on('child_changed', (data) => {
                 const changedMessage = data.val();
                 const messageId = data.key;
                 console.log(`[${userName}] child_changed event: Message ${messageId} changed to:`, changedMessage); // Debugging log con nombre de usuario

                 // Si el mensaje cambiado es del usuario actual y su estado es 'read', actualizar la UI
                 if (changedMessage.name === userName && changedMessage.status === 'read') {
                     const messageElement = chatBox.querySelector(`[data-message-id="${messageId}"]`);
                     if (messageElement) {
                         // Encontrar el message-footer dentro del mensaje
                         const messageFooter = messageElement.querySelector('.message-footer');
                         if (messageFooter) {
                             // Eliminar checkmarks existentes si los hay
                             const existingCheckmarks = messageFooter.querySelector('.checkmarks');
                             if (existingCheckmarks) {
                                 existingCheckmarks.remove();
                             }

                             const checkmarksSpan = document.createElement('span');
                             checkmarksSpan.classList.add('checkmarks');
                             checkmarksSpan.textContent = '九九'; // Doble checkmark Unicode
                             // A침adir los checkmarks al final del message-footer
                             messageFooter.appendChild(checkmarksSpan);
                             console.log(`[${userName}] Updated message ${messageId} to double check.`); // Debugging log con nombre de usuario
                         }
                     }
                 }
             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for message changes (child_changed):`, error); // Debugging log con nombre de usuario
             });

             // Listener para reflejar borrados masivos del nodo 'messages' (por ejemplo, al limpiar el chat)
             messagesRef.on('value', (snapshot) => {
                 // Si el nodo no existe o queda vac칤o, limpiar el DOM del chat
                 if (!snapshot.exists()) {
                     clearChatUI();
                 }
             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for messages (value):`, error);
             });
        }

        function clearChatUI(){
            chatBox.innerHTML = '';
            typingIndicator.textContent = '';
            // Reset del estado de respuesta si estaba activo
            replyingToMessage = null;
            replyPreview.style.display = 'none';
            replyNameSpan.textContent = '';
            replyTextSpan.textContent = '';
            // Ocultar selector/men칰s abiertos
            emojiPicker.style.display = 'none';
            settingsDropdown.style.display = 'none';
            // Ajustar padding por si cambia la altura del 치rea fija
            adjustChatBoxPadding();
        }


        // --- Configurar Intersection Observer ---
        function setupMessageObserver() {
            const options = {
                root: chatBox, // Observar dentro del chatBox
                rootMargin: '0px',
                threshold: 0.5 // El mensaje se considera visible si al menos el 50% est치 en el viewport
            };

            messageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    // Si el mensaje es visible (intersecting) y es un mensaje recibido por este usuario
                    if (entry.isIntersecting && entry.target.classList.contains('received')) {
                        const messageElement = entry.target;
                        const messageId = messageElement.dataset.messageId;
                        // Obtener el estado actual del mensaje de la base de datos para evitar escrituras innecesarias
                        messagesRef.child(messageId).once('value', (snapshot) => {
                            const messageData = snapshot.val();
                            // Mark as read only if the status is not already 'read'
                            if (messageData && messageData.status !== 'read') {
                                console.log(`[${userName}] Message ${messageId} is now visible. Marking as read.`);
                                messagesRef.child(messageId).update({ status: 'read' })
                                    .then(() => console.log(`[${userName}] Message ${messageId} marked as read successfully via Observer.`))
                                    .catch(error => console.error(`[${userName}] Error marking message ${messageId} as read via Observer:`, error));
                            } else {
                                console.log(`[${userName}] Message ${messageId} is visible but already read or not found.`);
                            }
                        });
                        // Dejar de observar este mensaje una vez que se marca como le칤do
                        observer.unobserve(messageElement);
                    }
                });
            }, options);
             console.log(`[${userName}] Intersection Observer configured.`);
        }


        // Funci칩n para mostrar un mensaje en el DOM
        function displayMessage(msg, messageId) {
            console.log(`[${userName}] Displaying message:`, msg, "ID:", messageId); // Debugging log con nombre de usuario

            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.dataset.messageId = messageId; // Almacenar el ID del mensaje en el elemento DOM

            // A침adir clase 'sent' o 'received'
            if (msg.name === userName) {
                messageElement.classList.add('sent');
                 console.log(`[${userName}] Message ${messageId} is SENT. Initial status: ${msg.status}`); // Log initial status for sent message
            } else {
                messageElement.classList.add('received');
                 console.log(`[${userName}] Message ${messageId} is RECEIVED from ${msg.name}.`); // Debugging log con nombre de usuario
                // La l칩gica para marcar como le칤do ahora est치 en el Intersection Observer
            }

            // Crear elementos para el nombre y contenido
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('name');
            /* Solo mostrar el nombre si no es el mensaje del usuario actual (opcional, estilo WhatsApp) */
            if (msg.name !== userName) {
               nameSpan.textContent = msg.name + ': ';
            } else {
               nameSpan.textContent = ''; // No mostrar el nombre en mensajes propios
            }

            // Crear el contenedor para el texto, hora y checkmarks
            const messageFooter = document.createElement('div');
            messageFooter.classList.add('message-footer');

            // Crear elementos para el texto y timestamp
            const textSpan = document.createElement('span');
            textSpan.classList.add('text');
            textSpan.textContent = msg.text;
            console.log(`[${userName}] textSpan created for message ${messageId}. Content: "${textSpan.textContent}"`); // Debugging log: contenido del texto

            // --- Aplicar estilos inline para asegurar visibilidad y color ---
            // Estos estilos inline tienen alta prioridad y deber칤an forzar la visibilidad y color.
            textSpan.style.visibility = 'visible';
            textSpan.style.display = 'block'; // O 'inline-block' si prefieres
            if (msg.name === userName) {
                textSpan.style.color = 'white'; // Color blanco para mensajes enviados
            } else {
                textSpan.style.color = '#1c1c1e'; // Color oscuro para mensajes recibidos
            }
            console.log(`[${userName}] textSpan for message ${messageId} inline styles applied -> Color: ${textSpan.style.color}, Visibility: ${textSpan.style.visibility}, Display: ${textSpan.style.display}`); // Log inline styles


            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = formatTimestamp(msg.timestamp); // Formatear y mostrar hora


            // A침adir nombre al elemento del mensaje si no es el usuario actual
            if (msg.name !== userName) {
                 messageElement.appendChild(nameSpan);
            }

            // --- Mostrar contenido de la respuesta si existe ---
            if (msg.replyTo) {
                const replyContentDiv = document.createElement('div');
                replyContentDiv.classList.add('reply-content');

                const replyName = document.createElement('span');
                replyName.classList.add('reply-name');
                replyName.textContent = msg.replyTo.name + ':';

                const replyText = document.createElement('span');
                replyText.classList.add('reply-text');
                replyText.textContent = msg.replyTo.content;

                replyContentDiv.appendChild(replyName);
                replyContentDiv.appendChild(replyText);
                messageElement.appendChild(replyContentDiv);
            }
            /* --- Fin de mostrar contenido de respuesta --- */

            // --- L칩gica para detectar y mostrar previsualizaci칩n de videos o enlaces ---
            let contentElement = null; // Elemento que contendr치 la previsualizaci칩n o el texto del enlace

            // 1. Intentar detectar YouTube
            const youtubeUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?([a-zA-Z0-9_-]+)/) : null;
            if (youtubeUrlMatch && youtubeUrlMatch[1]) {
                const videoId = youtubeUrlMatch[1];
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.youtube.com/embed/${videoId}`; // URL de incrustaci칩n est치ndar de YouTube
                iframe.setAttribute('allowfullscreen', ''); // Permitir pantalla completa
                iframe.setAttribute('loading', 'lazy'); // Carga diferida
                contentElement = iframe;
                console.log(`[${userName}] YouTube video detected for message ${messageId}. Video ID: ${videoId}`);
            } else {
                // 2. Intentar detectar Facebook Video (regex mejorada, pero puede no ser exhaustiva)
                const facebookUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:facebook\.com)\/(?:watch\/)?(?:v=)?(?:videos\/)?([0-9]+)(?:\/)?/) : null;
                 if (facebookUrlMatch && facebookUrlMatch[1]) {
                     const videoId = facebookUrlMatch[1];
                     const iframe = document.createElement('iframe');
                     // URL de incrustaci칩n b치sica de Facebook (puede requerir ajustes dependiendo de la configuraci칩n)
                     iframe.src = `https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fwatch%2F%3Fv%3D${videoId}&show_text=0&width=560`;
                     iframe.setAttribute('allowfullscreen', '');
                     iframe.setAttribute('loading', 'lazy');
                     iframe.setAttribute('scrolling', 'no');
                     iframe.setAttribute('frameborder', '0');
                     iframe.setAttribute('allow', 'autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share');
                     contentElement = iframe;
                     console.log(`[${userName}] Facebook video detected for message ${messageId}. Video ID: ${videoId}`);
                 } else {
                     // 3. Intentar detectar enlaces directos a archivos de video
                     const videoFileMatch = msg.text ? msg.text.match(/(https?:\/\/[^\s]+\.(mp4|webm|ogg))/) : null;
                     if (videoFileMatch && videoFileMatch[1]) {
                         const videoUrl = videoFileMatch[1];
                         const videoElement = document.createElement('video');
                         videoElement.src = videoUrl;
                         videoElement.setAttribute('controls', ''); // Mostrar controles de video
                         videoElement.setAttribute('preload', 'metadata'); // Cargar metadatos primero
                         contentElement = videoElement;
                         console.log(`[${userName}] Direct video file detected for message ${messageId}. URL: ${videoUrl}`);
                     } else {
                         // 4. Si no es un video soportado, mostrar el texto del mensaje con enlaces clicables
                         // Detectar URLs generales en el texto y convertirlas en enlaces clicables
                         const urlRegex = /(https?:\/\/[^\s]+)/g;
                         const textWithLinks = msg.text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
                         textSpan.innerHTML = textWithLinks; // Usar innerHTML para renderizar el enlace
                         contentElement = textSpan; // El texto con enlaces es el contenido principal
                         console.log(`[${userName}] No supported video detected for message ${messageId}. Displaying text with links.`);
                     }
                 }
            }

            // Si se encontr칩 una previsualizaci칩n de video, crear un contenedor y a침adirla
            if (contentElement && (contentElement.tagName === 'IFRAME' || contentElement.tagName === 'VIDEO')) {
                const videoPreviewContainer = document.createElement('div');
                videoPreviewContainer.classList.add('video-preview-container');
                videoPreviewContainer.appendChild(contentElement);
                messageElement.appendChild(videoPreviewContainer); // A침adir el contenedor de previsualizaci칩n al messageElement

                // Despu칠s de a침adir la previsualizaci칩n, a침adir el texto original si no es solo la URL
                 if (msg.text && !youtubeUrlMatch && !facebookUrlMatch && !videoFileMatch) {
                     // Si el mensaje conten칤a texto adem치s de la URL, a침adir el textSpan original (ahora con enlaces clicables)
                     messageElement.appendChild(textSpan);
                     console.log(`[${userName}] Adding original textSpan after video preview for message ${messageId}.`);
                 } else if (msg.text && (youtubeUrlMatch || facebookUrlMatch || videoFileMatch)) {
                     // Si el mensaje es solo la URL del video, no es necesario a침adir el textSpan de nuevo
                     console.log(`[${userName}] Message is only a video URL, not adding textSpan again for message ${messageId}.`);
                 }


            } else if (contentElement && contentElement.classList.contains('text')) {
                 // Si el contenido principal es el textSpan (con enlaces clicables)
                 messageElement.appendChild(contentElement); // A침adir el textSpan (que ya tiene el contenido)
                 console.log(`[${userName}] Adding textSpan as main content for message ${messageId}.`);
            }


            // --- A침adir hora y checkmarks al footer ---
            messageFooter.appendChild(timestampSpan); // A침adir la hora

            // A침adir checkmarks si es un mensaje enviado por el usuario actual
            if (msg.name === userName) {
                 const checkmarksSpan = document.createElement('span');
                 checkmarksSpan.classList.add('checkmarks');
                 // Mostrar un check simple si el estado es 'sent', doble si es 'read'
                 checkmarksSpan.textContent = msg.status === 'read' ? '九九' : '九'; // Unicode checkmarks
                 messageFooter.appendChild(checkmarksSpan); // A침adir los checkmarks al footer
                 console.log(`[${userName}] Displaying checkmarks for SENT message ${messageId}: ${checkmarksSpan.textContent}, based on status "${msg.status}"`); // Debugging log con nombre de usuario
            } else {
                 console.log(`[${userName}] Not displaying checkmarks for RECEIVED message ${messageId}.`); // Debugging log con nombre de usuario
            }

            messageElement.appendChild(messageFooter); // Asegurarse de que el footer se a침ade al messageElement
            console.log(`[${userName}] messageFooter appended to messageElement for message ${messageId}.`); // Log after appending messageFooter

            chatBox.appendChild(messageElement);
            console.log(`[${userName}] messageElement appended to chatBox for message ${messageId}.`); // Log after appending messageElement
            console.log(`[${userName}] chatBox after appending message ${messageId}:`, chatBox.innerHTML); // Log chatBox content


            // Despu칠s de a침adir el messageElement al DOM, podemos obtener los estilos computados del textSpan
            // Aumentar el retraso para dar m치s tiempo a la renderizaci칩n
            setTimeout(() => {
                 // Verificar si textSpan existe antes de intentar obtener estilos computados
                 if (textSpan && textSpan.parentElement) { // Asegurarse de que textSpan est치 en el DOM
                     const computedStyle = window.getComputedStyle(textSpan);
                     console.log(`[${userName}] textSpan for message ${messageId} computed style -> Color: ${computedStyle.color}, Visibility: ${computedStyle.visibility}, Display: ${computedStyle.display}`);
                 } else {
                     console.log(`[${userName}] textSpan not found in DOM for message ${messageId}. Skipping computed style log.`);
                 }


                 // Verificar tambi칠n el estilo computado del messageFooter
                 const computedFooterStyle = window.getComputedStyle(messageFooter);
                 console.log(`[${userName}] messageFooter for message ${messageId} computed style -> Display: ${computedFooterStyle.display}, Visibility: ${computedFooterStyle.visibility}, Opacity: ${computedFooterStyle.opacity}`);

                 // Observar el mensaje si es un mensaje recibido
                 if (messageElement.classList.contains('received')) {
                     messageObserver.observe(messageElement);
                     console.log(`[${userName}] Observing received message ${messageId} with Intersection Observer.`);
                 }


            }, 500); // Retraso aumentado a 500ms


             // Reproducir sonido solo para mensajes entrantes que no sean del usuario actual
             if (initialLoadComplete && msg.name !== userName) {
                 playNotificationSound();
             }

             // A침adir listener de clic para responder
             messageElement.addEventListener('click', () => {
                 // Crear un objeto con los datos necesarios para la respuesta
                 const messageDataForReply = {
                     id: messageId,
                     name: msg.name,
                     text: msg.text || '', // Usar texto si existe, vac칤o si es archivo
                     // Puedes a침adir m치s propiedades si quieres referenciar archivos en el futuro
                 };
                 startReply(messageDataForReply);
             });
        }

        // Funci칩n para reproducir el sonido de notificaci칩n
        function playNotificationSound() {
             if (notificationSound && audioUnlocked) { // Solo reproducir si el audio est치 desbloqueado
                 notificationSound.currentTime = 0; // Reiniciar el sonido si ya se est치 reproduciendo
                 notificationSound.play().catch(error => {
                     console.error("Error al reproducir el sonido:", error);
                     // Esto a menudo ocurre si el navegador bloquea el autoplay
                 });
             } else if (!audioUnlocked) {
                 console.log("Audio not unlocked yet. Cannot play sound.");
             }
        }

        // Funci칩n para intentar desbloquear el audio con una interacci칩n del usuario
        function unlockAudio() {
            if (notificationSound && notificationSound.readyState >= 2 && !audioUnlocked) { // readyState 2 means enough data is available
                notificationSound.volume = 0; // Set volume to 0
                const playPromise = notificationSound.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // Playback started successfully
                        notificationSound.pause(); // Pause immediately
                        notificationSound.volume = 1; // Restore volume
                        audioUnlocked = true; // Mark audio as unlocked
                        console.log("Audio unlocked successfully.");
                        // Remove this listener after first interaction
                        document.removeEventListener('click', unlockAudio);
                        document.removeEventListener('touchstart', unlockAudio);
                        sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
                    }).catch(error => {
                        // Playback failed, likely due to user interaction requirement
                        console.error("Audio unlock failed:", error);
                        audioUnlocked = false; // Keep audio locked
                    });
                }
            } else if (audioUnlocked) {
                 console.log("Audio already unlocked.");
                 // Remove listeners if already unlocked
                 document.removeEventListener('click', unlockAudio);
                 document.removeEventListener('touchstart', unlockAudio);
                 sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
            } else {
                 console.log("Notification sound not ready or not found.");
            }
        }


        // --- Custom Modal Helpers ---
        const lockOverlay = document.getElementById('lock-overlay');
        const passwordModal = document.getElementById('password-modal');
        const pwInput = document.getElementById('pw-modal-input');
        const pwError = document.getElementById('pw-modal-error');
        const pwTitle = document.getElementById('pw-modal-title');
        const promptModal = document.getElementById('prompt-modal');
        const promptInput = document.getElementById('prompt-modal-input');
        const promptTitle = document.getElementById('prompt-modal-title');
        const lockChatButton = document.getElementById('lock-chat-button');

        // Show a password modal and return a promise that resolves true/false
        function showPasswordModal(title){
            return new Promise(resolve => {
                pwTitle.textContent = title || 'Ingresa la clave';
                pwInput.value = '';
                pwError.textContent = '';
                passwordModal.classList.add('active');
                pwInput.focus();

                function cleanup(){ passwordModal.classList.remove('active'); pwInput.removeEventListener('keypress', onKey); }
                function onKey(e){ if(e.key==='Enter') document.getElementById('pw-modal-ok').click(); }
                pwInput.addEventListener('keypress', onKey);

                document.getElementById('pw-modal-ok').onclick = () => {
                    const val = pwInput.value.trim();
                    if(val === CLEAR_CHAT_PASSWORD){
                        cleanup(); resolve(true);
                    } else {
                        pwError.textContent = 'Clave incorrecta';
                        pwInput.value = '';
                        pwInput.focus();
                    }
                };
                document.getElementById('pw-modal-cancel').onclick = () => { cleanup(); resolve(false); };
            });
        }

        // Show a text prompt modal (replaces browser prompt)
        function showPromptModal(title, placeholder){
            return new Promise(resolve => {
                promptTitle.textContent = title || 'Ingresa un valor';
                promptInput.value = '';
                promptInput.placeholder = placeholder || '';
                promptModal.classList.add('active');
                promptInput.focus();

                function cleanup(){ promptModal.classList.remove('active'); promptInput.removeEventListener('keypress', onKey); }
                function onKey(e){ if(e.key==='Enter') document.getElementById('prompt-modal-ok').click(); }
                promptInput.addEventListener('keypress', onKey);

                document.getElementById('prompt-modal-ok').onclick = () => { const v = promptInput.value.trim(); cleanup(); resolve(v || null); };
                document.getElementById('prompt-modal-cancel').onclick = () => { cleanup(); resolve(null); };
            });
        }


        // --- L칩gica de BLOQUEO GLOBAL (Firebase RTDB) ---
        function setupChatLockListener(){
            chatLockRef.on('value', (snapshot) => {
                const data = snapshot.val();
                const isLocked = data && data.locked === true;
                if(isLocked){
                    lockOverlay.classList.add('active');
                    console.log('Chat bloqueado globalmente por:', data.lockedBy || 'desconocido');
                } else {
                    lockOverlay.classList.remove('active');
                    console.log('Chat desbloqueado.');
                }
            });
        }

        lockChatButton.addEventListener('click', () => {
            settingsDropdown.style.display = 'none';
            chatLockRef.set({ locked: true, lockedBy: userName || 'admin', lockedAt: firebase.database.ServerValue.TIMESTAMP })
                .then(() => console.log('Bloqueo activado globalmente'))
                .catch(err => console.error('Error al bloquear:', err));
        });

        // Ayuda = desbloquear con clave
        document.getElementById('lock-help-btn').addEventListener('click', async () => {
            const ok = await showPasswordModal('Ingresa la clave para desbloquear');
            if(ok){
                chatLockRef.set({ locked: false })
                    .then(() => console.log('Chat desbloqueado globalmente'))
                    .catch(err => console.error('Error al desbloquear:', err));
            }
        });

        // M치s opciones = borrar chat con clave
        document.getElementById('lock-more-btn').addEventListener('click', async () => {
            const ok = await showPasswordModal('Ingresa la clave para borrar el chat');
            if(ok){
                try {
                    await messagesRef.remove();
                    console.log('Chat limpiado desde bloqueo');
                    clearChatUI();
                    await chatLockRef.set({ locked: false });
                } catch(err){ console.error('Error al limpiar chat:', err); }
            }
        });


        // --- L칩gica para Limpiar Chat con Clave (Realtime Database) ---
        clearChatButton.addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            const ok = await showPasswordModal('Ingresa la clave para limpiar el chat');
            if(ok){
                messagesRef.remove()
                    .then(() => {
                        console.log("Chat limpiado exitosamente en Realtime Database!");
                        clearChatUI();
                    })
                    .catch((error) => {
                        console.error("Error al limpiar el chat en Realtime Database:", error);
                    });
            }
        });

        // --- L칩gica para Cambiar Nombre ---
        changeNameButton.addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            const newName = await showPromptModal('Ingresa tu nuevo nombre', 'Nuevo nombre');
            if (newName && newName !== userName) {
                userName = newName;
                localStorage.setItem('chatName', userName);
                console.log(`Nombre cambiado a: ${userName}`);
                location.reload();
            }
        });


        // --- L칩gica del Bot칩n de Emoji y Selector ---

        // Lista de emojis para el selector
       const emojis = [
  // Caras y personas
  '游', '游때', '游땍', '游뱎', '游땎', '游땏', '游땐', '游땑', '游땔', '游땕', '游땖', '游땙', '游땘', '游땢', '游봃', '游땡', '游땣', '游땤', '驕쥞잺', '游뗵', '游뱅', '游뱔', '游뱂', '游뱓', '游땛', '游땜', '游땼', '游뗷', '游땚', '游땪', '游땬', '游땵', '游밿', '游땶', '游땱', '游땲', '游봄', '游땺', '游땗', '游땥', '游땦', '游땧', '游뱏', '游', '游땝', '游땞', '游땟', '游뗶', '游뱀', '游', '驕좶잺', '游뗴', '游땠', '游', '游', '游땫', '游땩', '游땴', '游땭', '游땮', '游땯', '游땰', '游뱚', '游땳', '游땷', '游땸', '游봇', '游봈', '游땹', '游뱕', '游땻', '游봆', '游', '游땨', '游뱗', '游땽', '游', '游뱃', '游뱍', '游뱙', '游뱒', '游땒', '游봅', '游봌', '游', '游뱌', '游봅', '游뱖', '游뱘', '游븷', '游뱁', '游땓', '游', '游놏', '游놐', '游', '游놑', '游놓', '游뱄', '游눨',
  // Corazones y gestos
  '游떀', '游땾', '游땿', '游떁', '游떂', '游떃', '游', '游', '游', '游뗻', '游뗼', '游뗽', '游눎', '游눏', '游눚', '游눟', '游눘', '游눙', '游눕', '游', '游눗', '游', '仇勇', '游눖', '仇벒잺', '游비', '游눝', '游눜', '游눛', '游눞', '游밽', '游둯', '游밼', '游눮', '游눡', '游눤', '游눪', '游눥', '游눧', '游돕勇', '游눢', '游눫', '游녜勇꽳릥뻞잺', '游딛勇', '游딢勇', '游눬', '游눣', '游녦', '游뱈', '游둟勇', '九', '游둤', '游녧', '游밾', '九껊잺', '游', '游', '游뱆', '游뱇', '游녣', '游녤', '游녡', '游둣', '游녢', '驕뢢잺', '游녨', '游녩', '九', '游녥', '游뱉', '游뱊', '游녪', '游뗿', '游녫', '游', '游뱋', '游똂'
];

        // Llenar el selector de emojis
        emojis.forEach(emoji => {
            const emojiSpan = document.createElement('span');
            emojiSpan.textContent = emoji;
            emojiPicker.appendChild(emojiSpan);

            // A침adir listener para insertar el emoji en el input
            emojiSpan.addEventListener('click', () => {
                insertEmoji(emoji);
                // Opcional: Ocultar el selector despu칠s de seleccionar un emoji
                // emojiPicker.style.display = 'none';
            });
        });

        // Funci칩n para insertar emoji en el textarea en la posici칩n del cursor
        function insertEmoji(emoji) {
            const textarea = messageInput;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const value = textarea.value;

            textarea.value = value.substring(0, start) + emoji + value.substring(end);

            // Mover el cursor despu칠s del emoji insertado
            textarea.selectionStart = textarea.selectionEnd = start + emoji.length;

            // Disparar un evento 'input' para que la l칩gica de auto-ajuste de altura y typing indicator se active
            const event = new Event('input', { bubbles: true });
            textarea.dispatchEvent(event);

            textarea.focus(); // Mantener el foco en el textarea
        }


        // Listener para el bot칩n de emoji para mostrar/ocultar el selector
        emojiButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el bot칩n cierre el selector inmediatamente
            event.stopPropagation();
             // Ocultar el dropdown de settings si est치 visible
             settingsDropdown.style.display = 'none';

            if (emojiPicker.style.display === 'flex') {
                emojiPicker.style.display = 'none';
            } else {
                // Posicionar el selector justo encima de la barra de input
                // bottom del selector = altura del 치rea de input + padding/margen
                const inputAreaHeight = bottomFixedArea.offsetHeight; // Usar la altura del contenedor fijo
                emojiPicker.style.bottom = `${inputAreaHeight + 10}px`; // 10px de margen
                emojiPicker.style.display = 'flex';
            }
        });

        // Ocultar el selector de emojis y el dropdown de settings si se hace clic fuera de ellos
        document.addEventListener('click', (event) => {
            // Si el clic no fue dentro del selector de emojis ni en el bot칩n de emoji
            if (!emojiPicker.contains(event.target) && event.target !== emojiButton) {
                emojiPicker.style.display = 'none';
            }
             // Si el clic no fue dentro del dropdown de settings ni en el bot칩n de settings
             if (!settingsDropdown.contains(event.target) && event.target !== settingsButton) {
                 settingsDropdown.style.display = 'none';
             }
        });


        // --- L칩gica para Ajustar Layout con Teclado Virtual ---

        // Funci칩n para ajustar el padding inferior del chatBox
        function adjustChatBoxPadding() {
            // Usar un peque침o retraso para asegurar que el DOM est칠 renderizado y las alturas sean correctas
            setTimeout(() => {
                 // Usar la altura del nuevo contenedor fijo
                 const bottomAreaHeight = bottomFixedArea.offsetHeight;
                 // A침adir un buffer m치s grande para asegurar espacio suficiente
                 // Puedes ajustar este valor (80) para aumentar o disminuir el espacio inferior
                 const newPaddingBottom = bottomAreaHeight + 80; // <--- Aqu칤 puedes modificar el valor del buffer
                 chatBox.style.paddingBottom = `${newPaddingBottom}px`;
                 console.log(`[${userName}] Adjusted paddingBottom of chatBox to ${chatBox.style.paddingBottom}`); // Debugging log con nombre de usuario
                 console.log(`[${userName}] bottomFixedArea.offsetHeight: ${bottomAreaHeight}`); // Debugging log con nombre de usuario
                 // Intentar scrollear al final despu칠s de ajustar el padding
                 chatBox.scrollTop = chatBox.scrollHeight;
            }, 300); // Aumentar el retraso a 300ms
        }


        // Listener para el evento resize de la ventana
        window.addEventListener('resize', adjustChatBoxPadding);

        // Listener para el evento 'focus' en el input de mensaje
        messageInput.addEventListener('focus', () => {
             // Intentar scrollear la caja de chat al final cuando el input recibe foco
             // Esto ayuda a asegurar que la barra de input sea visible
             setTimeout(() => {
                 chatBox.scrollTop = chatBox.scrollHeight;
                 console.log(`[${userName}] Input enfocado, scrolleando chatBox al final con retraso.`); // Debugging log con nombre de usuario
             }, 150); // Retraso para dar tiempo al layout a ajustarse
        });


        // --- L칩gica de Responder Mensajes ---

        // Funci칩n para iniciar el modo de respuesta
        function startReply(messageData) {
            replyingToMessage = messageData; // Almacenar los datos del mensaje
            replyNameSpan.textContent = messageData.name + ':';
            // Mostrar un fragmento del texto o indicar que es un archivo
            replyTextSpan.textContent = messageData.text ? messageData.text.substring(0, 50) + (messageData.text.length > 50 ? '...' : '') : 'Archivo'; // Asumiendo solo texto por ahora

            replyPreview.style.display = 'flex'; // Mostrar la vista previa
            messageInput.focus(); // Poner el foco en el campo de mensaje
            // Ajustar padding despu칠s de mostrar la vista previa
            adjustChatBoxPadding();
        }

        // Funci칩n para cancelar el modo de respuesta
        function cancelReply() {
            replyingToMessage = null; // Limpiar la referencia al mensaje
            replyPreview.style.display = 'none'; // Ocultar la vista previa
            replyNameSpan.textContent = '';
            replyTextSpan.textContent = '';
            // Ajustar padding despu칠s de ocultar la vista previa
            adjustChatBoxPadding();
        }

        // Listener para el bot칩n de cancelar respuesta
        cancelReplyButton.addEventListener('click', cancelReply);


        // --- L칩gica del Bot칩n de Configuraci칩n y Dropdown ---

        // Listener para el bot칩n de configuraci칩n para mostrar/ocultar el dropdown
        settingsButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el bot칩n cierre el dropdown inmediatamente
            event.stopPropagation();
             // Ocultar el selector de emojis si est치 visible
             emojiPicker.style.display = 'none';

            if (settingsDropdown.style.display === 'flex') {
                settingsDropdown.style.display = 'none';
            } else {
                // Posicionar el dropdown justo debajo y a la derecha del bot칩n de settings
                // Esto se maneja principalmente con CSS position: absolute y top/right
                settingsDropdown.style.display = 'flex';
                // La posici칩n top y right ya est치n definidas en CSS, pero podr칤as ajustarlas din치micamente si fuera necesario
                // const settingsButtonRect = settingsButton.getBoundingClientRect();
                // settingsDropdown.style.top = `${settingsButtonRect.bottom + 5}px`; // 5px debajo del bot칩n
                // settingsDropdown.style.right = `${window.innerWidth - settingsButtonRect.right}px`; // Alinear a la derecha del bot칩n
            }
        });


        // --- L칩gica de Presencia (Usuarios en L칤nea) ---
        function setupPresence() {
             if (!userName) return;

             const userPresenceRef = presenceRef.child(userName);

             // Establecer la presencia a true cuando el usuario se conecta
             userPresenceRef.set(true);
             console.log(`[${userName}] Presence set to true.`);

             // Eliminar la presencia cuando el usuario se desconecta inesperadamente
             userPresenceRef.onDisconnect().remove()
                 .then(() => console.log(`[${userName}] onDisconnect configured to remove presence.`))
                 .catch(error => console.error(`[${userName}] Error configuring onDisconnect:`, error));


             // Establecer la presencia a false cuando el usuario abandona la p치gina (cierra pesta침a, navega)
             window.addEventListener('beforeunload', () => {
                 console.log(`[${userName}] beforeunload event detected. Setting presence to false.`);
                 userPresenceRef.set(false); // Establecer a false expl칤citamente
             });

             window.addEventListener('unload', () => {
                 console.log(`[${userName}] unload event detected. Setting presence to false.`);
                 userPresenceRef.set(false); // Establecer a false expl칤citamente
             });


             // Escuchar cambios en el nodo de presencia para actualizar la lista de usuarios en l칤nea
             presenceRef.on('value', (snapshot) => {
                 const onlineUsers = snapshot.val();
                 const usersOnline = [];

                 if (onlineUsers) {
                     for (const name in onlineUsers) {
                         // Solo considerar usuarios cuya presencia es expl칤citamente true y no el usuario actual
                         if (onlineUsers[name] === true && name !== userName) {
                             usersOnline.push(name);
                         }
                     }
                 }

                 // Actualizar el elemento en la interfaz
                 if (usersOnline.length > 0) {
                     onlineUsersDiv.textContent = `En l칤nea: ${usersOnline.join(', ')}`;
                 } else {
                     onlineUsersDiv.textContent = 'Nadie m치s en l칤nea';
                 }
                 console.log(`[${userName}] Online users updated: ${onlineUsersDiv.textContent}. Raw data:`, onlineUsers);
             }, (error) => {
                 console.error(`[${userName}] Error in presence listener:`, error);
             });
        }


        // Comprobar si hay un nombre guardado en localStorage al cargar la p치gina
        const savedName = localStorage.getItem('chatName');
        if (savedName) {
            nameInput.value = savedName; // Rellenar el campo de nombre
            // No llamar a startChatButton.click() aqu칤, initializeChat se llama en window.onload
        }

        // Ajustes iniciales al cargar la p치gina
        window.onload = function() {
             // Si hay un nombre guardado, inicializar el chat
             if (localStorage.getItem('chatName')) {
                 userName = localStorage.getItem('chatName');
                 namePrompt.style.display = 'none'; // Ocultar la secci칩n de nombre
                 chatInterface.style.display = 'flex'; // Mostrar la interfaz de chat
                 initializeChat(); // Inicializar la carga de mensajes y listeners
             }
             // Ajustar el padding inferior del chatBox al cargar
             adjustChatBoxPadding();

             // Add initial click/touch listeners to unlock audio
             document.addEventListener('click', unlockAudio, { once: true });
             document.addEventListener('touchstart', unlockAudio, { once: true });
             sendButton.addEventListener('click', unlockAudio, { once: true }); // Also try on send button click


        };


    </script>

</body>
</html>
